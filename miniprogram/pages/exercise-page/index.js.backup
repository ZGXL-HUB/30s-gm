const questionsData = require('../../data/intermediate_questions.js');
const writingNouns = require('../../data/writing_nouns.js');
const writingTenses = require('../../data/writing_tenses.js');

// å›ºå®šåè¯åç¼€æç¤ºå†…å®¹
const NOUN_SUFFIX_HINT = "å¸¸è§çš„åè¯åç¼€æœ‰-nessã€-thã€-mentã€-ionã€-ureã€-ityã€-orã€-erã€-istã€-ismã€-alã€-hoodã€-shipã€-domç­‰ã€‚";

Page({
  data: {
    level: '',
    grammarPoint: '',
    questions: [],
    answers: [],
    results: [],
    submitting: false,
    correctionCompleted: false, // æ‰¹æ”¹å®ŒæˆçŠ¶æ€
    wrongQuestions: [],
    mode: 'normal', // normal, practice, review
    selectedPoints: [],
    
    // è¡¨æ ¼ç»ƒä¹ ç›¸å…³
    exerciseType: '', // 'grammar' æˆ– 'writing'
    tableData: null,
    tableAnswers: {},
    correctAnswers: {},
    showCorrect: {},
    
    // æç¤ºç›¸å…³
    showHintModal: false,
    hintOptions: ["å®¾æ ¼", "å½¢å®¹è¯æ€§ç‰©ä¸»ä»£è¯", "åè¯æ€§ç‰©ä¸»ä»£è¯", "åèº«ä»£è¯"],
    currentHint: "",

    // ç­”æ¡ˆç›¸å…³
    showAnswerModal: false,
    currentAnswer: null,
    // æ–°å¢ï¼šæç¤ºå†…å®¹å¼¹çª—
    showHintContentModal: false,
    hintContent: "",

    // æ–°å¢ï¼šè¡ŒçŠ¶æ€
    rowStatus: {},

    // æ–°å¢ï¼šnoun_004ç›¸å…³
    noun004ShowFullRule: [false, false, false, false, false],
    noun004InputStatus: {},

    // ä»£è¯è¡¨æ ¼ç›¸å…³
    pronounUserInputs: {}, // å­˜å‚¨ç”¨æˆ·è¾“å…¥
    pronounInputStatus: {}, // å­˜å‚¨è¾“å…¥çŠ¶æ€ï¼šcorrect/wrong/ç©º
    
    // ç°åœ¨åˆ†è¯è¡¨æ ¼ç›¸å…³
    presentParticipleShowFullRule: [false, false, false, false, false],
    presentParticipleInputStatus: {},
    
    // è¿‡å»åˆ†è¯è¡¨æ ¼ç›¸å…³
    pastParticipleShowFullRule: [false, false, false, false, false],
    pastParticipleInputStatus: {},
    
    // æ—¶æ€ä¹¦å†™è¡¨æ ¼ç›¸å…³
    tenseWritingShowFullRule: [false, false, false, false, false, false, false, false], // 8è¡Œè§„åˆ™å…¨æ–‡æ˜¾ç¤ºçŠ¶æ€
    tenseWritingInputStatus: {},
    
    // æ¯”è¾ƒçº§æœ€é«˜çº§è¡¨æ ¼ç›¸å…³
    prefixSuffixInputStatus: {},
    comparativeInputStatus: {},
    superlativeInputStatus: {},
    comparativeShowFullRule: [false, false, false, false, false],
    superlativeShowFullRule: [false, false, false, false, false],
    
    // å‰¯è¯è¡¨æ ¼ç›¸å…³
    adverbInputStatus: {},
    adverbShowFullRule: [false, false, false, false, false, false],
    
    // ç‰¹æ®Šç±»åˆ«å¼•å¯¼ç›¸å…³
    hasSpecialCategory: false,
    showSpecialGuide: false,
    
    // é”™é¢˜å˜å¼ç»ƒä¹ ç›¸å…³
    isWrongQuestionVariant: false,
    
    // é”™é¢˜æ¶ˆç­ç»ƒä¹ ç›¸å…³
    isWrongQuestionElimination: false,
    
    // æ–°å¢ï¼šæ˜¯å¦æœ‰é”™é¢˜çš„æ ‡å¿—
    hasWrongQuestions: false,

    // æ–°å¢ï¼šçŸ¥è¯†ç‚¹åŒå‘è”åŠ¨æ¨¡å—ç›¸å…³
    showSuffixCard: false, // åç¼€çŸ¥è¯†å¡ç‰‡æ˜¾ç¤ºçŠ¶æ€
    showRuleCard: false, // ä¹¦å†™è§„åˆ™å¡ç‰‡æ˜¾ç¤ºçŠ¶æ€
    errorCounts: {}, // å„è¯­æ³•ç‚¹é”™è¯¯æ¬¡æ•°ç»Ÿè®¡ï¼Œå¦‚ { 'noun-plural': 3 }
    currentQuestionIndex: 0, // å½“å‰é¢˜ç›®ç´¢å¼•
    currentQuestionType: '', // å½“å‰é¢˜ç›®ç±»å‹
  },

  getRandomQuestionsFromSubClass(subClassKey, count = 5) {
    let questionsData;
    switch(this.data.level) {
      case 'åˆçº§':
        questionsData = require('../../data/beginner_questions.js');
        break;
      case 'é«˜çº§':
        questionsData = require('../../data/advanced_questions.js');
        break;
      default:
        questionsData = require('../../data/intermediate_questions.js');
    }
    const arr = questionsData[subClassKey] || [];
    const shuffled = arr.slice().sort(() => Math.random() - 0.5);
    return shuffled.slice(0, Math.min(count, shuffled.length));
  },

  onLoad(options) {
    const { questions, mode, level, tables, type, hasSpecialCategory, isWrongQuestionVariant, isWrongQuestionElimination } = options;
    this.dataSourceType = type; // ä¿å­˜ç±»å‹
    
    // æ£€æŸ¥æ˜¯å¦åŒ…å«ç‰¹æ®Šç±»åˆ«
    const hasSpecial = hasSpecialCategory === 'true';
    // æ£€æŸ¥æ˜¯å¦ä¸ºé”™é¢˜å˜å¼ç»ƒä¹ 
    const isWrongVariant = isWrongQuestionVariant === 'true';
    // æ£€æŸ¥æ˜¯å¦ä¸ºé”™é¢˜æ¶ˆç­ç»ƒä¹ 
    const isWrongElimination = isWrongQuestionElimination === 'true';
    
    console.log('é”™é¢˜æ¶ˆç­ç»ƒä¹ å‚æ•°:', {
      isWrongQuestionElimination,
      isWrongElimination,
      mode,
      level
    });
    
    this.setData({
      hasSpecialCategory: hasSpecial,
      isWrongQuestionVariant: isWrongVariant,
      isWrongQuestionElimination: isWrongElimination
    });
    
    // åˆ¤æ–­æ˜¯å¦ä¸ºè¡¨æ ¼ç»ƒä¹ 
    if (type && tables) {
      this.initTableExercise(tables);
    } else {
      this.initGrammarExercise(questions, mode, level);
    }
  },

  // åˆå§‹åŒ–è¡¨æ ¼ç»ƒä¹ 
  initTableExercise(tables) {
    const tableIds = tables.split(',');
    let dataSource = null;
    
    // å¤„ç†æ··åˆç±»å‹çš„æƒ…å†µ
    if (this.dataSourceType === 'mixed') {
      // å¯¹äºæ··åˆç±»å‹ï¼Œæˆ‘ä»¬éœ€è¦æ ¹æ®æ¯ä¸ªè¡¨æ ¼IDæ¥ç¡®å®šå…¶æ•°æ®æº
      // è¿™é‡Œæˆ‘ä»¬å°†ä½¿ç”¨ä¸€ä¸ªç»Ÿä¸€çš„æ•°æ®æºå¯¹è±¡æ¥å­˜å‚¨æ‰€æœ‰è¡¨æ ¼æ•°æ®
      const pronounData = require('../../data/writing_pronouns.js');
      const nounData = require('../../data/writing_nouns.js');
      const tenseData = require('../../data/writing_tenses.js');
      const voiceData = require('../../data/writing_voices.js');
      const comparisonData = require('../../data/writing_comparisons.js');
      const adverbData = require('../../data/writing_adverbs.js');
      
      // åˆå¹¶æ‰€æœ‰æ•°æ®æºï¼Œé¿å…å±æ€§å†²çª
      dataSource = {
        // ä»£è¯æ•°æ®
        ...pronounData,
        // åè¯å’ŒåŠ¨è¯æ•°æ®
        ...nounData,
        // æ—¶æ€æ•°æ®
        ...tenseData,
        // è¯­æ€æ•°æ®
        ...voiceData,
        // æ¯”è¾ƒçº§æ•°æ®
        ...comparisonData,
        // å‰¯è¯æ•°æ®
        ...adverbData,
        // åˆå¹¶æ‰€æœ‰questionsæ•°ç»„
        questions: [
          ...(pronounData.questions || []),
          ...(nounData.questions || []),
          ...(tenseData.questions || []),
          ...(voiceData.questions || []),
          ...(comparisonData.questions || []),
          ...(adverbData.questions || [])
        ]
      };
    } else if (this.dataSourceType === 'noun') {
      dataSource = require('../../data/writing_nouns.js');
    } else if (this.dataSourceType === 'pronoun') {
      dataSource = require('../../data/writing_pronouns.js');
    } else if (this.dataSourceType === 'verb') {
      dataSource = require('../../data/writing_nouns.js'); // åŠ¨è¯æ•°æ®ä¹Ÿåœ¨è¿™ä¸ªæ–‡ä»¶ä¸­
    } else if (this.dataSourceType === 'tense') {
      dataSource = require('../../data/writing_tenses.js');
    } else if (this.dataSourceType === 'voice') {
      dataSource = require('../../data/writing_voices.js');
    } else if (this.dataSourceType === 'comparison') {
      dataSource = require('../../data/writing_comparisons.js');
    } else if (this.dataSourceType === 'adverb') {
      dataSource = require('../../data/writing_adverbs.js');
    }
    // è·å–è¡¨æ ¼æ•°æ®
    const tableData = {};
    const correctAnswers = {};
    const tableAnswers = {}; // åˆå§‹åŒ–tableAnswers
    const showCorrect = {}; // åˆå§‹åŒ–showCorrect

    tableIds.forEach(tableId => {
      let tableDataSource = null;
      
      // ç»Ÿä¸€æ•°æ®è®¿é—®æ–¹å¼ - æ ¹æ®æ•°æ®æºç±»å‹å¤„ç†
      if (dataSource) {
        if (this.dataSourceType === 'mixed') {
          // æ··åˆç±»å‹éœ€è¦ä»æ‰€æœ‰æ•°æ®æºä¸­æŸ¥æ‰¾å¯¹åº”çš„è¡¨æ ¼æ•°æ®
          // é¦–å…ˆå°è¯•ç›´æ¥è®¿é—®
          if (dataSource[tableId]) {
            tableDataSource = dataSource[tableId];
          } else {
            // å¦‚æœç›´æ¥è®¿é—®å¤±è´¥ï¼Œå°è¯•ä»questionsæ•°ç»„ä¸­è¿‡æ»¤
            const allQuestions = [];
            // æ”¶é›†æ‰€æœ‰æ•°æ®æºä¸­çš„questionsæ•°ç»„
            if (dataSource.questions) {
              allQuestions.push(...dataSource.questions);
            }
            // æŸ¥æ‰¾å¯¹åº”table_idçš„æ•°æ®
            tableDataSource = allQuestions.filter(item => item.table_id === tableId);
            
            // å¦‚æœè¿˜æ˜¯æ²¡æœ‰æ‰¾åˆ°ï¼Œå°è¯•ä»å„ä¸ªç‹¬ç«‹çš„æ•°æ®æºä¸­æŸ¥æ‰¾
            if (!tableDataSource || tableDataSource.length === 0) {
              const pronounData = require('../../data/writing_pronouns.js');
              const nounData = require('../../data/writing_nouns.js');
              const tenseData = require('../../data/writing_tenses.js');
              const voiceData = require('../../data/writing_voices.js');
              const comparisonData = require('../../data/writing_comparisons.js');
              const adverbData = require('../../data/writing_adverbs.js');
              
              // ä¾æ¬¡æ£€æŸ¥æ¯ä¸ªæ•°æ®æº
              if (pronounData[tableId]) {
                tableDataSource = pronounData[tableId];
              } else if (nounData[tableId]) {
                tableDataSource = nounData[tableId];
              } else if (tenseData[tableId]) {
                tableDataSource = tenseData[tableId];
              } else if (voiceData[tableId]) {
                tableDataSource = voiceData[tableId];
              } else if (comparisonData[tableId]) {
                tableDataSource = comparisonData[tableId];
              } else if (adverbData[tableId]) {
                tableDataSource = adverbData[tableId];
              } else {
                // æœ€åå°è¯•ä»å„ä¸ªæ•°æ®æºçš„questionsæ•°ç»„ä¸­æŸ¥æ‰¾
                const allDataSources = [pronounData, nounData, tenseData, voiceData, comparisonData, adverbData];
                for (const source of allDataSources) {
                  if (source.questions) {
                    const found = source.questions.filter(item => item.table_id === tableId);
                    if (found.length > 0) {
                      tableDataSource = found;
                      break;
                    }
                  }
                }
              }
            }
          }
        } else if (this.dataSourceType === 'adverb') {
          // å‰¯è¯æ•°æ®ä»questionsæ•°ç»„ä¸­è¿‡æ»¤å‡ºå¯¹åº”table_idçš„æ•°æ®
          tableDataSource = dataSource.questions.filter(item => item.table_id === tableId);
        } else if (dataSource[tableId]) {
          // å…¶ä»–æ•°æ®æºç›´æ¥è®¿é—®å±æ€§
          tableDataSource = dataSource[tableId];
        }
      }
      
      if (tableDataSource && Array.isArray(tableDataSource)) {
        tableData[tableId] = tableDataSource;
        // åˆå§‹åŒ–ç­”æ¡ˆ
        const answers = {};
        const correct = {};
        const showCorrectForTable = {};
        tableDataSource.forEach(cell => {
          if (!cell.is_header) {
            answers[cell.cell_id] = '';
            correct[cell.cell_id] = cell.correctAnswer || cell.answer;
            showCorrectForTable[cell.cell_id] = null;
          }
        });
        tableAnswers[tableId] = answers;
        correctAnswers[tableId] = correct;
        showCorrect[tableId] = showCorrectForTable;
      }
    });

    this.setData({
      exerciseType: 'writing',
      tableData,
      correctAnswers,
      tableAnswers,
      showCorrect
    });

    // ç”Ÿæˆ noun_001_rows ç”¨äºæ¸²æŸ“
    if (tableData['noun_001']) {
      const rows = [];
      const cells = tableData['noun_001'];
      for (let i = 0; i < cells.length; i += 2) {
        rows.push({
          left: cells[i].question,
          cell_id: cells[i+1].cell_id
        });
      }
      this.setData({
        ['tableData.noun_001_rows']: rows
      });
    }

    console.log('=== æ•°æ®åŠ è½½è°ƒè¯•ä¿¡æ¯ ===');
    console.log('dataSourceType:', this.dataSourceType);
    console.log('tableIds:', tableIds);
    console.log('dataSource keys:', dataSource ? Object.keys(dataSource) : 'null');
    console.log('tableData keys:', Object.keys(tableData));
    console.log('tableAnswers keys:', Object.keys(tableAnswers));
    
    // è¯¦ç»†æ£€æŸ¥æ¯ä¸ªè¡¨æ ¼çš„æ•°æ®
    tableIds.forEach(tableId => {
      console.log(`è¡¨æ ¼ ${tableId}:`, {
        exists: !!tableData[tableId],
        length: tableData[tableId] ? tableData[tableId].length : 0,
        firstCell: tableData[tableId] ? tableData[tableId][0] : null
      });
    });

    // æ·»åŠ setDataåçš„éªŒè¯
    console.log('=== setDataåéªŒè¯ ===');
    console.log('this.data.exerciseType:', this.data.exerciseType);
    console.log('this.data.tableData keys:', this.data.tableData ? Object.keys(this.data.tableData) : 'null');
    console.log('this.data.tableAnswers keys:', this.data.tableAnswers ? Object.keys(this.data.tableAnswers) : 'null');
    
    // æ£€æŸ¥ç¬¬ä¸€ä¸ªè¡¨æ ¼çš„å…·ä½“æ•°æ®
    const firstTableId = tableIds[0];
    if (firstTableId) {
      console.log(`ç¬¬ä¸€ä¸ªè¡¨æ ¼ ${firstTableId} çš„æ•°æ®:`, {
        inTableData: !!this.data.tableData[firstTableId],
        dataLength: this.data.tableData[firstTableId] ? this.data.tableData[firstTableId].length : 0,
        sampleData: this.data.tableData[firstTableId] ? this.data.tableData[firstTableId].slice(0, 3) : null
      });
    }

    if (tableData['noun_004']) {
      this.setData({
        noun004ShowFullRule: [false, false, false, false, false],
        noun004InputStatus: {}
      });
    }

    if (tableData['present_participle_001']) {
      this.setData({
        presentParticipleShowFullRule: [false, false, false, false, false],
        presentParticipleInputStatus: {}
      });
    }

    if (tableData['past_participle_001']) {
      this.setData({
        pastParticipleShowFullRule: [false, false, false, false, false],
        pastParticipleInputStatus: {}
      });
    }
    
    if (tableData['tense_writing_001']) {
      this.setData({
        tenseWritingShowFullRule: [false, false, false, false, false, false, false, false],
        tenseWritingInputStatus: {}
      });
    }

    if (tableData['adverb_writing_001']) {
      this.setData({
        adverbShowFullRule: [false, false, false, false, false, false],
        adverbInputStatus: {}
      });
    }
  },

  // ä»äº‘æ•°æ®åº“è·å–é¢˜ç›®
  async getQuestionsFromCloud(categories = [], count = 10) {
    try {
      console.log('ä»äº‘æ•°æ®åº“è·å–é¢˜ç›®ï¼Œåˆ†ç±»ï¼š', categories, 'æ•°é‡ï¼š', count);
      
      // æ£€æŸ¥äº‘å¼€å‘æ˜¯å¦å¯ç”¨
      if (!wx.cloud || !wx.cloud.database) {
        console.log('äº‘å¼€å‘ä¸å¯ç”¨ï¼Œä½¿ç”¨æœ¬åœ°æ•°æ®');
        return this.getLocalQuestions(categories, count);
      }
      
      let query = wx.cloud.database().collection('questions');
      
      // å¦‚æœæŒ‡å®šäº†åˆ†ç±»ï¼Œåˆ™æŒ‰åˆ†ç±»æŸ¥è¯¢
      if (categories && categories.length > 0) {
        query = query.where({
          category: wx.cloud.database().command.in(categories)
        });
      }
      
      const result = await query.get();
      console.log('âœ… äº‘æ•°æ®åº“æŸ¥è¯¢æˆåŠŸï¼Œè·å¾—', result.data.length, 'æ¡æ•°æ®');
      
      if (result.data && result.data.length > 0) {
        // æ˜¾ç¤ºå‰3æ¡æ•°æ®çš„analysiså­—æ®µçŠ¶æ€
        console.log('å‰3æ¡æ•°æ®çš„analysiså­—æ®µï¼š', result.data.slice(0, 3).map(doc => ({
          text: doc.text,
          hasAnalysis: !!doc.analysis,
          hasExplanation: !!doc.explanation,
          analysis: doc.analysis ? doc.analysis.substring(0, 50) + '...' : 'æ— ',
          explanation: doc.explanation ? doc.explanation.substring(0, 50) + '...' : 'æ— '
        })));
      
        // æ‰å¹³åŒ–é¢˜ç›®æ•°æ® - æ¯ä¸ªæ–‡æ¡£åŒ…å«ä¸€ä¸ªé¢˜ç›®
        let allQuestions = result.data.map(doc => {
          // å¤„ç† analysis å­—æ®µï¼šä¼˜å…ˆä½¿ç”¨ analysisï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨ explanation
          let analysis = doc.analysis || doc.explanation || '';
          
          // å¦‚æœæ˜¯ explanation å­—æ®µä¸”ä»¥ "analysis:" å¼€å¤´ï¼Œåˆ™å»æ‰è¿™ä¸ªå‰ç¼€
          if (analysis && analysis.startsWith('analysis:')) {
            analysis = analysis.substring(9).trim(); // å»æ‰ "analysis:" å‰ç¼€
          }
          
          return {
            text: doc.text,
            answer: doc.answer,
            analysis: analysis,
            category: doc.category
          };
        });
        
        // éšæœºæ‰“ä¹±å¹¶å–æŒ‡å®šæ•°é‡
        allQuestions = this.shuffleArray(allQuestions);
        allQuestions = allQuestions.slice(0, count);
        
        console.log('å¤„ç†åçš„é¢˜ç›®ï¼š', allQuestions);
        return allQuestions;
      } else {
        console.log('äº‘æ•°æ®åº“ä¸­æ²¡æœ‰æ‰¾åˆ°é¢˜ç›®ï¼Œä½¿ç”¨æœ¬åœ°æ•°æ®');
        return this.getLocalQuestions(categories, count);
      }
    } catch (error) {
      console.error('ä»äº‘æ•°æ®åº“è·å–é¢˜ç›®å¤±è´¥ï¼š', error);
      console.log('é™çº§ä½¿ç”¨æœ¬åœ°æ•°æ®');
      return this.getLocalQuestions(categories, count);
    }
  },

  // è·å–æœ¬åœ°é¢˜ç›®æ•°æ®ï¼ˆé™çº§æ–¹æ¡ˆï¼‰
  getLocalQuestions(categories = [], count = 10) {
    let questionsData;
    switch(this.data.level) {
      case 'åˆçº§':
        questionsData = require('../../data/beginner_questions.js');
        break;
      case 'é«˜çº§':
        questionsData = require('../../data/advanced_questions.js');
        break;
      default:
        questionsData = require('../../data/intermediate_questions.js');
    }
    
    let allQuestions = [];
    if (categories && categories.length > 0) {
      categories.forEach(category => {
        if (questionsData[category]) {
          allQuestions = allQuestions.concat(questionsData[category]);
        }
      });
    } else {
      // å¦‚æœæ²¡æœ‰æŒ‡å®šåˆ†ç±»ï¼Œè·å–æ‰€æœ‰é¢˜ç›®
      Object.values(questionsData).forEach(categoryQuestions => {
        allQuestions = allQuestions.concat(categoryQuestions);
      });
    }
    
    // éšæœºæ‰“ä¹±å¹¶å–æŒ‡å®šæ•°é‡
    allQuestions = this.shuffleArray(allQuestions);
    allQuestions = allQuestions.slice(0, count);
    
    return allQuestions;
  },

  // åˆå§‹åŒ–è¯­æ³•ç»ƒä¹ 
  async initGrammarExercise(questions, mode, level) {
    wx.showLoading({
      title: 'åŠ è½½é¢˜ç›®ä¸­...'
    });

    try {
      if (questions) {
        const parsedQuestions = JSON.parse(decodeURIComponent(questions));
        console.log('âœ… ä½¿ç”¨ä¼ å…¥çš„é¢˜ç›®å‚æ•°:', parsedQuestions);
        
        this.setData({
          exerciseType: 'grammar',
          questions: parsedQuestions,
          answers: new Array(parsedQuestions.length).fill(''),
          mode: mode || 'normal',
          level: level || 'ä¸­çº§',
          realTimeMode: true, // å¯ç”¨å®æ—¶æ‰¹æ”¹æ¨¡å¼
          results: new Array(parsedQuestions.length).fill(null) // åˆå§‹åŒ–ç»“æœæ•°ç»„
        });
      } else {
        console.log('ğŸ”„ æ²¡æœ‰ä¼ å…¥é¢˜ç›®å‚æ•°ï¼Œä»äº‘æ•°æ®åº“è·å–é¢˜ç›®...');
        
        // ä»äº‘æ•°æ®åº“è·å–é¢˜ç›®
        const cloudQuestions = await this.getQuestionsFromCloud(['ç»¼åˆç»ƒä¹ ', 'ä»‹è¯ç»¼åˆ', 'åè¯å¤æ•°ä¹¦å†™ç»¼åˆ'], 10);
        
        // æ£€æŸ¥é¢˜ç›®æ¥æº
        const hasAnalysis = cloudQuestions.some(q => q.analysis);
        console.log('ğŸ“Š é¢˜ç›®ç»Ÿè®¡:', {
          æ€»æ•°: cloudQuestions.length,
          æœ‰è§£æ: cloudQuestions.filter(q => q.analysis).length,
          æ— è§£æ: cloudQuestions.filter(q => !q.analysis).length,
          æ•°æ®æ¥æº: hasAnalysis ? 'äº‘æ•°æ®åº“' : 'æœ¬åœ°æ•°æ®ï¼ˆé™çº§ï¼‰'
        });
        
        // æ˜¾ç¤ºå‰3é¢˜çš„è§£æçŠ¶æ€
        console.log('ğŸ“ å‰3é¢˜è§£æçŠ¶æ€:', cloudQuestions.slice(0, 3).map(q => ({
          é¢˜ç›®: q.text.substring(0, 30) + '...',
          æœ‰è§£æ: !!q.analysis,
          è§£æ: q.analysis ? q.analysis.substring(0, 50) + '...' : 'æ— '
        })));
        
        this.setData({ 
          exerciseType: 'grammar',
          questions: cloudQuestions,
          answers: new Array(cloudQuestions.length).fill(''),
          mode: 'normal',
          level: level || 'ä¸­çº§',
          realTimeMode: true, // å¯ç”¨å®æ—¶æ‰¹æ”¹æ¨¡å¼
          results: new Array(cloudQuestions.length).fill(null) // åˆå§‹åŒ–ç»“æœæ•°ç»„
        });
      }
    } catch (error) {
      console.error('âŒ åˆå§‹åŒ–é¢˜ç›®å¤±è´¥ï¼š', error);
      wx.showToast({
        title: 'åŠ è½½é¢˜ç›®å¤±è´¥',
        icon: 'none'
      });
    } finally {
      wx.hideLoading();
    }
  },

  // å·¥å…·å‡½æ•°ï¼šå»é™¤å‰åçŸ­æ¨ªçº¿å¹¶å°å†™
  normalizeSuffix(str) {
    return (str || '').replace(/^-+/, '').replace(/-+$/, '').toLowerCase();
  },

  // æ£€æŸ¥ç­”æ¡ˆæ˜¯å¦æ­£ç¡®ï¼ˆæ”¯æŒå¤šç­”æ¡ˆæ ¼å¼ï¼‰
  checkAnswer(userAnswer, correctAnswer) {
    if (!userAnswer || !correctAnswer) return false;
    
    const userInput = userAnswer.trim().toLowerCase();
    const correct = correctAnswer.trim().toLowerCase();
    
    console.log(`[ç­”æ¡ˆåˆ¤å®š] ç”¨æˆ·ç­”æ¡ˆ: "${userAnswer}" -> "${userInput}"`);
    console.log(`[ç­”æ¡ˆåˆ¤å®š] æ­£ç¡®ç­”æ¡ˆ: "${correctAnswer}" -> "${correct}"`);
    
    // æ”¯æŒå¤šç­”æ¡ˆæ ¼å¼ï¼Œå¦‚ "which / that"
    if (correct.includes(' / ')) {
      // å¤šç­”æ¡ˆæ ¼å¼ï¼Œæ£€æŸ¥ç”¨æˆ·ç­”æ¡ˆæ˜¯å¦åŒ¹é…å…¶ä¸­ä»»ä¸€ç­”æ¡ˆ
      const correctAnswers = correct.split(' / ').map(ans => ans.trim());
      console.log(`[ç­”æ¡ˆåˆ¤å®š] å¤šç­”æ¡ˆæ ¼å¼ï¼Œæ­£ç¡®ç­”æ¡ˆåˆ—è¡¨: [${correctAnswers.join(', ')}]`);
      const result = correctAnswers.includes(userInput);
      console.log(`[ç­”æ¡ˆåˆ¤å®š] ç»“æœ: ${result}`);
      return result;
    } else {
      // å•ç­”æ¡ˆæ ¼å¼ï¼Œç›´æ¥æ¯”è¾ƒ
      const result = userInput === correct;
      console.log(`[ç­”æ¡ˆåˆ¤å®š] å•ç­”æ¡ˆæ ¼å¼ï¼Œç»“æœ: ${result}`);
      return result;
    }
  },

  // è¡¨æ ¼è¾“å…¥å¤„ç†
  onTableInput(e) {
    const { tableId, cellId } = e.currentTarget.dataset;
    const { value } = e.detail;
    
    const tableAnswers = { ...this.data.tableAnswers };
    if (!tableAnswers[tableId]) {
      tableAnswers[tableId] = {};
    }
    tableAnswers[tableId][cellId] = value;
    
    // æ£€æŸ¥ç­”æ¡ˆæ˜¯å¦æ­£ç¡®æˆ–é”™è¯¯
    const showCorrect = { ...this.data.showCorrect };
    if (!showCorrect[tableId]) {
      showCorrect[tableId] = {};
    }
    const correctAnswer = this.data.correctAnswers[tableId][cellId];
    
    if (!value || value.trim() === '') {
      showCorrect[tableId][cellId] = null; // æœªç­”
    } else {
      let isCorrect = false;
      
      if (tableId === 'noun_002') {
        // noun_002ç‰¹æ®Šå¤„ç†ï¼šç”¨æˆ·è¾“å…¥é€‰é¡¹å­—æ¯ï¼Œéœ€è¦è½¬æ¢ä¸ºå¯¹åº”å•è¯
        const userInput = value.trim().toUpperCase();
        if (userInput >= 'A' && userInput <= 'D') {
          const optionIndex = userInput.charCodeAt(0) - 65; // A=0, B=1, C=2, D=3
          const cellIndex = parseInt(cellId.split('_')[1]) - 1; // è·å–è¡Œå·
          const rowStartIndex = Math.floor(cellIndex / 4) * 4; // æ¯è¡Œ4ä¸ªé€‰é¡¹
          const targetCellIndex = rowStartIndex + optionIndex;
          
          if (this.data.tableData[tableId][targetCellIndex]) {
            const selectedWord = this.data.tableData[tableId][targetCellIndex].question;
            isCorrect = this.normalizeSuffix(selectedWord) === this.normalizeSuffix(correctAnswer);
          }
        }
                } else {
            // å…¶ä»–è¡¨æ ¼çš„å¸¸è§„éªŒè¯
            if (correctAnswer && correctAnswer.includes(' / ')) {
              // å¤šç­”æ¡ˆæ ¼å¼ï¼Œæ£€æŸ¥ç”¨æˆ·ç­”æ¡ˆæ˜¯å¦åŒ¹é…å…¶ä¸­ä»»ä¸€ç­”æ¡ˆ
              const correctAnswers = correctAnswer.split(' / ').map(ans => this.normalizeSuffix(ans.trim()));
              const userInput = this.normalizeSuffix(value.trim());
              isCorrect = correctAnswers.includes(userInput);
            } else {
              // å•ç­”æ¡ˆæ ¼å¼ï¼Œç›´æ¥æ¯”è¾ƒ
              isCorrect = correctAnswer && (this.normalizeSuffix(value.trim()) === this.normalizeSuffix(correctAnswer));
            }
          }
      
      showCorrect[tableId][cellId] = isCorrect;
    }
    
    this.setData({
      tableAnswers,
      showCorrect
    });
  },

  // ç‚¹å‡»é€‰æ‹©å¤„ç†ï¼ˆç”¨äºnoun_002ï¼‰
  onChoiceSelect(e) {
    const { tableId, cellId, option, word } = e.currentTarget.dataset;
    
    const tableAnswers = { ...this.data.tableAnswers };
    if (!tableAnswers[tableId]) {
      tableAnswers[tableId] = {};
    }
    tableAnswers[tableId][cellId] = option;
    
    // æ£€æŸ¥ç­”æ¡ˆæ˜¯å¦æ­£ç¡®æˆ–é”™è¯¯
    const showCorrect = { ...this.data.showCorrect };
    if (!showCorrect[tableId]) {
      showCorrect[tableId] = {};
    }
    const correctAnswer = this.data.correctAnswers[tableId][cellId];
    
    // éªŒè¯é€‰æ‹©çš„å•è¯æ˜¯å¦æ­£ç¡®
    const isCorrect = this.normalizeSuffix(word) === this.normalizeSuffix(correctAnswer);
    showCorrect[tableId][cellId] = isCorrect;

    // è®¡ç®—å½“å‰è¡Œå·
    let rowStatus = this.data.rowStatus || {};
    if (tableId === 'noun_002') {
      const cellIdx = Object.keys(this.data.tableAnswers[tableId]).indexOf(cellId);
      const allCells = this.data.tableData[tableId];
      // é€šè¿‡cell_idè§£æè¡Œå·
      const rowIdx = parseInt(cellId.split('_')[1]) ? Math.floor((parseInt(cellId.split('_')[1])-1)/4) : 0;
      // æ‰¾åˆ°è¯¥è¡Œçš„4ä¸ªcell_id
      const rowCellIds = allCells.slice(rowIdx*4, rowIdx*4+4).map(cell => cell.cell_id);
      // åˆ¤æ–­æœ¬è¡Œæ˜¯å¦æœ‰é€‰ä¸­ä¸”æ˜¯å¦æ­£ç¡®
      let found = false;
      for (let i = 0; i < 4; i++) {
        const cid = rowCellIds[i];
        if (tableAnswers[tableId][cid]) {
          found = true;
          if (showCorrect[tableId][cid] === true) {
            rowStatus[rowIdx] = 'correct';
            break;
          } else if (showCorrect[tableId][cid] === false) {
            rowStatus[rowIdx] = 'wrong';
          }
        }
      }
      if (!found) rowStatus[rowIdx] = null;
    }
    
    this.setData({
      tableAnswers,
      showCorrect,
      rowStatus
    });
  },

  // æäº¤è¡¨æ ¼ç­”æ¡ˆ
  submitTableAnswers() {
    const tableAnswers = this.data.tableAnswers;
    const correctAnswers = this.data.correctAnswers;
    const showCorrect = { ...this.data.showCorrect };
    let rowStatus = {};
    
    // æ£€æŸ¥æ‰€æœ‰è¡¨æ ¼çš„æ‰€æœ‰ç­”æ¡ˆ
    Object.keys(tableAnswers).forEach(tableId => {
      Object.keys(tableAnswers[tableId]).forEach(cellId => {
        const userAnswer = tableAnswers[tableId][cellId];
        const correctAnswer = correctAnswers[tableId][cellId];
        
        if (!userAnswer || userAnswer.trim() === '') {
          showCorrect[tableId][cellId] = null; // æœªç­”
        } else {
          let isCorrect = false;
          
          if (tableId === 'noun_002') {
            // noun_002ç‰¹æ®Šå¤„ç†ï¼šç”¨æˆ·é€‰æ‹©çš„æ˜¯é€‰é¡¹å­—æ¯ï¼Œéœ€è¦è½¬æ¢ä¸ºå¯¹åº”å•è¯
            const userInput = userAnswer.trim().toUpperCase();
            if (userInput >= 'A' && userInput <= 'D') {
              const optionIndex = userInput.charCodeAt(0) - 65; // A=0, B=1, C=2, D=3
              const cellIndex = parseInt(cellId.split('_')[1]) - 1; // è·å–è¡Œå·
              const rowStartIndex = Math.floor(cellIndex / 4) * 4; // æ¯è¡Œ4ä¸ªé€‰é¡¹
              const targetCellIndex = rowStartIndex + optionIndex;
              
              if (this.data.tableData[tableId][targetCellIndex]) {
                const selectedWord = this.data.tableData[tableId][targetCellIndex].question;
                isCorrect = this.normalizeSuffix(selectedWord) === this.normalizeSuffix(correctAnswer);
              }
            }
          } else {
            // å…¶ä»–è¡¨æ ¼çš„å¸¸è§„éªŒè¯
            if (correctAnswer && correctAnswer.includes(' / ')) {
              // å¤šç­”æ¡ˆæ ¼å¼ï¼Œæ£€æŸ¥ç”¨æˆ·ç­”æ¡ˆæ˜¯å¦åŒ¹é…å…¶ä¸­ä»»ä¸€ç­”æ¡ˆ
              const correctAnswers = correctAnswer.split(' / ').map(ans => this.normalizeSuffix(ans.trim()));
              const userInput = this.normalizeSuffix(userAnswer.trim());
              isCorrect = correctAnswers.includes(userInput);
            } else {
              // å•ç­”æ¡ˆæ ¼å¼ï¼Œç›´æ¥æ¯”è¾ƒ
              isCorrect = correctAnswer && (this.normalizeSuffix(userAnswer.trim()) === this.normalizeSuffix(correctAnswer));
            }
          }
          
          showCorrect[tableId][cellId] = isCorrect;
        }
      });
      // å¤„ç†noun_002æ•´è¡Œé«˜äº®
      if (tableId === 'noun_002') {
        const allCells = this.data.tableData[tableId];
        for (let rowIdx = 0; rowIdx < 16; rowIdx++) {
          const rowCellIds = allCells.slice(rowIdx*4, rowIdx*4+4).map(cell => cell.cell_id);
          let found = false;
          for (let i = 0; i < 4; i++) {
            const cid = rowCellIds[i];
            if (tableAnswers[tableId][cid]) {
              found = true;
              if (showCorrect[tableId][cid] === true) {
                rowStatus[rowIdx] = 'correct';
                break;
              } else if (showCorrect[tableId][cid] === false) {
                rowStatus[rowIdx] = 'wrong';
              }
            }
          }
          if (!found) rowStatus[rowIdx] = null;
        }
      }
    });
    
    this.setData({
      showCorrect,
      submitting: true,
      rowStatus
    });
    
    // è®¡ç®—æ­£ç¡®ç‡
    let totalCells = 0;
    let correctCells = 0;
    
    Object.keys(showCorrect).forEach(tableId => {
      Object.keys(showCorrect[tableId]).forEach(cellId => {
        if (showCorrect[tableId][cellId] !== null) {
          totalCells++;
          if (showCorrect[tableId][cellId] === true) {
            correctCells++;
          }
        }
      });
    });
    
    const accuracy = totalCells > 0 ? (correctCells / totalCells * 100).toFixed(1) : 0;
    
    // å»¶è¿Ÿè®¾ç½®ï¼Œæ¨¡æ‹Ÿæ‰¹æ”¹è¿‡ç¨‹
    setTimeout(() => {
      this.setData({
        submitting: false,
        correctionCompleted: true, // æ‰¹æ”¹å®Œæˆï¼Œæ˜¾ç¤ºåŒæŒ‰é’®
        hasWrongQuestions: false // è¡¨æ ¼ç»ƒä¹ ä¸äº§ç”Ÿé”™é¢˜
      });
      
      // æ˜¾ç¤ºæ‰¹æ”¹å®Œæˆæç¤º
      wx.showToast({
        title: `æ‰¹æ”¹å®Œæˆï¼æ­£ç¡®ç‡ï¼š${accuracy}%`,
        icon: 'success',
        duration: 2000
      });
    }, 1500); // 1.5ç§’åæ˜¾ç¤ºæ‰¹æ”¹å®Œæˆ
  },

  generateQuestions() {
    const selectedPoints = this.data.selectedPoints;
    if (selectedPoints.length === 0) {
      wx.showToast({
        title: 'è¯·é€‰æ‹©è‡³å°‘ä¸€ä¸ªè¯­æ³•ç‚¹',
        icon: 'none'
      });
      return;
    }

    this.generateQuestionsFromCloud(selectedPoints);
  },

  async generateQuestionsFromCloud(categories) {
    wx.showLoading({
      title: 'ç”Ÿæˆé¢˜ç›®ä¸­...'
    });

    try {
      const generatedQuestions = await this.getQuestionsFromCloud(categories, 10);
      
      this.setData({
        questions: generatedQuestions,
        answers: new Array(generatedQuestions.length).fill(''),
        results: [],
        submitting: false
      });
    } catch (error) {
      console.error('ç”Ÿæˆé¢˜ç›®å¤±è´¥ï¼š', error);
      wx.showToast({
        title: 'ç”Ÿæˆé¢˜ç›®å¤±è´¥',
        icon: 'none'
      });
    } finally {
      wx.hideLoading();
    }
  },

  useLocalQuestions() {
    // ç°åœ¨ä¹Ÿä»äº‘æ•°æ®åº“è·å–é¢˜ç›®
    this.generateQuestionsFromCloud(this.data.selectedPoints || ['ç»¼åˆç»ƒä¹ ']);
  },

  shuffleArray(array) {
    const shuffled = array.slice();
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  },

  onInput(e) {
    const index = e.currentTarget.dataset.index;
    const value = e.detail.value;
    const answers = [...this.data.answers];
    answers[index] = value;
    this.setData({ answers });
    
    // ç§»é™¤å®æ—¶æ‰¹æ”¹ï¼Œæ”¹ä¸ºåœ¨å¤±å»ç„¦ç‚¹æ—¶æ‰¹æ”¹
    // this.realTimeCheck(index, value);
  },

  // æ–°å¢ï¼šå¤±å»ç„¦ç‚¹æ—¶è¿›è¡Œæ‰¹æ”¹
  onInputBlur(e) {
    const index = e.currentTarget.dataset.index;
    const value = e.detail.value;
    
    // åªæœ‰å½“ç”¨æˆ·è¾“å…¥äº†å†…å®¹ä¸”å¤±å»ç„¦ç‚¹æ—¶æ‰è¿›è¡Œæ‰¹æ”¹
    if (value && value.trim() !== '') {
      this.realTimeCheck(index, value);
    }
  },

  // æ–°å¢ï¼šå¤±å»ç„¦ç‚¹æ—¶æ‰¹æ”¹æ–¹æ³•
  realTimeCheck(index, value) {
    // å¦‚æœç”¨æˆ·è¾“å…¥ä¸ºç©ºï¼Œä¸è¿›è¡Œæ‰¹æ”¹
    if (!value || value.trim() === '') {
      return;
    }
    
    const question = this.data.questions[index];
    if (!question) {
      return;
    }
    
    const correctAnswer = question.answer || '';
    const isCorrect = this.checkAnswer(value, correctAnswer);
    
    console.log(`[å¤±å»ç„¦ç‚¹æ‰¹æ”¹] ç¬¬${index + 1}é¢˜: ç”¨æˆ·ç­”æ¡ˆ"${value}" vs æ­£ç¡®ç­”æ¡ˆ"${correctAnswer}" -> ${isCorrect ? 'æ­£ç¡®' : 'é”™è¯¯'}`);
    
    // æ›´æ–°ç»“æœæ•°ç»„
    const results = [...this.data.results];
    results[index] = {
      correct: isCorrect,
      answer: correctAnswer,
      analysis: question.analysis || question.explanation || ''
    };
    
    this.setData({ results });
    
    // å¦‚æœç­”æ¡ˆé”™è¯¯ï¼Œè¿›è¡Œé”™é¢˜ç»Ÿè®¡
    if (!isCorrect) {
      console.log(`[å¤±å»ç„¦ç‚¹æ‰¹æ”¹] ç¬¬${index + 1}é¢˜é”™è¯¯ï¼Œå¼€å§‹ç»Ÿè®¡`);
      
      // å¤„ç† analysis å­—æ®µ
      let analysis = question.analysis || question.explanation || '';
      if (analysis && analysis.startsWith('analysis:')) {
        analysis = analysis.substring(9).trim();
      }
      
      // åˆ›å»ºé”™é¢˜å¯¹è±¡
      const wrongQuestion = {
        question: question.question || question.text || question,
        userAnswer: value,
        correctAnswer: correctAnswer,
        analysis: analysis,
        category: question.category,
        grammarPoint: question.grammarPoint
      };
      
      // è¿›è¡Œé”™é¢˜ç»Ÿè®¡å’Œä¸“é¡¹ç»ƒä¹ è§¦å‘
      this.handleWrongQuestionWithProgress(wrongQuestion, index);
    }
  },

  submitAnswers() {
    if (this.data.submitting) return;
    
    this.setData({ submitting: true });
    
    const questions = this.data.questions;
    const answers = this.data.answers;
    const results = [];
    let correctCount = 0;
    const wrongQuestions = [];
    
    questions.forEach((question, index) => {
      const userAnswer = answers[index] || '';
      const correctAnswer = question.answer || '';
      
      console.log(`[æäº¤ç­”æ¡ˆ] ç¬¬${index + 1}é¢˜:`);
      console.log(`[æäº¤ç­”æ¡ˆ] é¢˜ç›®: ${question.text || question.question}`);
      console.log(`[æäº¤ç­”æ¡ˆ] ç”¨æˆ·ç­”æ¡ˆ: "${userAnswer}"`);
      console.log(`[æäº¤ç­”æ¡ˆ] æ­£ç¡®ç­”æ¡ˆ: "${correctAnswer}"`);
      
      // ä½¿ç”¨ç»Ÿä¸€çš„ç­”æ¡ˆåˆ¤å®šå‡½æ•°
      const isCorrect = this.checkAnswer(userAnswer, correctAnswer);
      
      console.log(`[æäº¤ç­”æ¡ˆ] åˆ¤å®šç»“æœ: ${isCorrect}`);
      
      if (isCorrect) {
        correctCount++;
      } else {
        // å¤„ç† analysis å­—æ®µï¼šä¼˜å…ˆä½¿ç”¨ analysisï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨ explanation
        let analysis = question.analysis || question.explanation || '';
        
        // å¦‚æœæ˜¯ explanation å­—æ®µä¸”ä»¥ "analysis:" å¼€å¤´ï¼Œåˆ™å»æ‰è¿™ä¸ªå‰ç¼€
        if (analysis && analysis.startsWith('analysis:')) {
          analysis = analysis.substring(9).trim(); // å»æ‰ "analysis:" å‰ç¼€
        }
        
        wrongQuestions.push({
          question: question.question || question.text || question,
          userAnswer: answers[index],
          correctAnswer: question.answer,
          analysis: analysis, // æ·»åŠ è§£æå­—æ®µ
          category: question.category, // ä¿å­˜åŸå§‹åˆ†ç±»ä¿¡æ¯
          grammarPoint: question.grammarPoint // ä¿å­˜è¯­æ³•ç‚¹ä¿¡æ¯
        });

        // æ³¨æ„ï¼šå®æ—¶æ‰¹æ”¹å·²ç»å¤„ç†äº†é”™é¢˜ç»Ÿè®¡ï¼Œè¿™é‡Œä¸å†é‡å¤å¤„ç†
        // åªæœ‰åœ¨éå®æ—¶æ‰¹æ”¹æ¨¡å¼ä¸‹æ‰éœ€è¦å¤„ç†
        if (!this.data.realTimeMode) {
          this.handleWrongQuestionWithProgress(question, index);
        }
      }
      
      // å¤„ç† analysis å­—æ®µï¼šä¼˜å…ˆä½¿ç”¨ analysisï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨ explanation
      let analysis = question.analysis || question.explanation || '';
      
      // å¦‚æœæ˜¯ explanation å­—æ®µä¸”ä»¥ "analysis:" å¼€å¤´ï¼Œåˆ™å»æ‰è¿™ä¸ªå‰ç¼€
      if (analysis && analysis.startsWith('analysis:')) {
        analysis = analysis.substring(9).trim(); // å»æ‰ "analysis:" å‰ç¼€
      }
      
      results.push({
        correct: isCorrect,
        answer: question.answer,
        analysis: analysis // æ·»åŠ è§£æå­—æ®µ
      });
    });
    
    const accuracy = (correctCount / questions.length * 100).toFixed(1);
    
    // å»¶è¿Ÿè®¾ç½®ï¼Œæ¨¡æ‹Ÿæ‰¹æ”¹è¿‡ç¨‹
    setTimeout(() => {
      this.setData({
        results,
        wrongQuestions,
        submitting: false,
        correctionCompleted: true, // æ‰¹æ”¹å®Œæˆï¼Œæ˜¾ç¤ºåŒæŒ‰é’®
        hasWrongQuestions: wrongQuestions.length > 0, // æ›´æ–°æ˜¯å¦æœ‰é”™é¢˜çš„æ ‡å¿—
        // å¦‚æœæœ‰ç‰¹æ®Šç±»åˆ«ï¼Œæ˜¾ç¤ºå¼•å¯¼
        showSpecialGuide: this.data.hasSpecialCategory
      });

      // ä¿å­˜é”™é¢˜åˆ°æœ¬åœ°å­˜å‚¨
      if (wrongQuestions.length > 0) {
        this.saveWrongQuestions(wrongQuestions);
      }

      // æ–°å¢ï¼šæ›´æ–°é”™é¢˜æ­£ç¡®æ¬¡æ•°ï¼ˆå½“ç”¨æˆ·åšå¯¹é¢˜ç›®æ—¶ï¼‰
      const correctQuestions = questions.filter((question, index) => {
        const userAnswer = answers[index] || '';
        const correctAnswer = question.answer || '';
        return this.checkAnswer(userAnswer, correctAnswer);
      });
      
      if (correctQuestions.length > 0) {
        this.updateWrongQuestionCorrectCount(correctQuestions);
      }

      // ä¿å­˜ç»ƒä¹ è®°å½•
      this.savePracticeHistory({
        total: questions.length,
        correct: correctCount,
        score: Math.round(accuracy),
        date: new Date().toLocaleDateString(),
        title: this.data.level ? `${this.data.level}ç»ƒä¹ ` : 'è¯­æ³•ç»ƒä¹ '
      });
      
      // æ˜¾ç¤ºæ‰¹æ”¹å®Œæˆæç¤º
      wx.showToast({
        title: `æ‰¹æ”¹å®Œæˆï¼æ­£ç¡®ç‡ï¼š${accuracy}%`,
        icon: 'success',
        duration: 2000
      });
    }, 1500); // 1.5ç§’åæ˜¾ç¤ºæ‰¹æ”¹å®Œæˆ
  },

  // è·³è½¬åˆ°ä¹¦å†™è§„èŒƒé¡µé¢
  navigateToWritingRules() {
    wx.switchTab({
      url: '/pages/grammar-writing/index'
    });
  },

  restart() {
    if (this.data.exerciseType === 'writing') {
      // é‡ç½®è¡¨æ ¼ç»ƒä¹ 
      const tableAnswers = {};
      const showCorrect = {};
      
      Object.keys(this.data.tableAnswers).forEach(tableId => {
        tableAnswers[tableId] = {};
        showCorrect[tableId] = {};
        
        Object.keys(this.data.tableAnswers[tableId]).forEach(cellId => {
          tableAnswers[tableId][cellId] = '';
          showCorrect[tableId][cellId] = null;
        });
      });
      
      this.setData({
        tableAnswers,
        showCorrect,
        submitting: false,
        correctionCompleted: false
      });
    } else {
      // é‡ç½®è¯­æ³•ç»ƒä¹ 
      this.setData({
        answers: new Array(this.data.questions.length).fill(''),
        results: [],
        submitting: false,
        correctionCompleted: false,
        wrongQuestions: [],
        hasWrongQuestions: false
      });
    }
  },

  // æ˜¾ç¤ºæç¤ºé€‰é¡¹
  showHintOptions() {
    console.log('showHintOptions called');
    
    // æ ¹æ®å½“å‰è¡¨æ ¼ç±»å‹æä¾›ä¸åŒçš„æç¤ºé€‰é¡¹
    const tableIds = Object.keys(this.data.tableData);
    console.log('Current tableIds:', tableIds);
    
    let hintOptions = [];
    
    if (tableIds.length > 0) {
      const firstTableId = tableIds[0];
      console.log('Processing hints for tableId:', firstTableId);
      
      if (firstTableId.startsWith('pronoun_')) {
        // ä»£è¯è¡¨æ ¼ - ä½¿ç”¨writing_pronouns.jsä¸­çš„hintsé”®å
        const writingPronouns = require('../../data/writing_pronouns.js');
        hintOptions = Object.keys(writingPronouns.hints);
        console.log('Pronoun hint options:', hintOptions);
      } else if (firstTableId.startsWith('noun_')) {
        // åè¯è¡¨æ ¼
        const writingNouns = require('../../data/writing_nouns.js');
        hintOptions = Object.keys(writingNouns.hints);
      } else if (firstTableId.includes('present_participle')) {
        hintOptions = ["ç°åœ¨åˆ†è¯æ„æˆè§„åˆ™"];
      } else if (firstTableId.includes('past_participle')) {
        hintOptions = ["è¿‡å»åˆ†è¯æ„æˆè§„åˆ™"];
      } else if (firstTableId.includes('comparison')) {
        if (firstTableId.includes('comparative')) {
          hintOptions = ["æ¯”è¾ƒçº§æ„æˆè§„åˆ™"];
        } else if (firstTableId.includes('superlative')) {
          hintOptions = ["æœ€é«˜çº§æ„æˆè§„åˆ™"];
        } else {
          hintOptions = ["æ¯”è¾ƒçº§æ„æˆè§„åˆ™", "æœ€é«˜çº§æ„æˆè§„åˆ™"];
        }
      } else if (firstTableId.includes('adverb')) {
        hintOptions = ["å‰¯è¯æ„æˆè§„åˆ™"];
      } else {
        // é€šç”¨é€‰é¡¹
        hintOptions = ["è¯­æ³•è§„åˆ™æç¤º", "ç»ƒä¹ æŠ€å·§", "å¸¸è§é”™è¯¯"];
      }
    } else {
      // æ²¡æœ‰è¡¨æ ¼æ•°æ®æ—¶çš„é»˜è®¤é€‰é¡¹
      hintOptions = ["è¯­æ³•è§„åˆ™æç¤º", "ç»ƒä¹ æŠ€å·§", "å¸¸è§é”™è¯¯"];
    }
    
    console.log('Final hintOptions:', hintOptions);
    
    this.setData({
      showHintModal: true,
      hintOptions: hintOptions
    });
  },

  // å…³é—­æç¤ºé€‰é¡¹å¼¹çª—
  closeHintModal() {
    this.setData({
      showHintModal: false
    });
  },

  // é€‰æ‹©æç¤ºç±»å‹
  selectHintType(e) {
    const hintType = e.currentTarget.dataset.type;
    console.log('selectHintType called with:', hintType);
    
    let hintContent = "";
    
    // æ ¹æ®å½“å‰è¡¨æ ¼ç±»å‹æ˜¾ç¤ºä¸åŒçš„æç¤º
    const tableIds = Object.keys(this.data.tableData);
    console.log('Current tableIds:', tableIds);
    
    if (tableIds.length > 0) {
      const firstTableId = tableIds[0];
      console.log('Processing hints for tableId:', firstTableId);
      
      if (firstTableId.startsWith('pronoun_')) {
        // ä»£è¯è¡¨æ ¼ - ä½¿ç”¨writing_pronouns.jsä¸­çš„hintsæ•°æ®
        const writingPronouns = require('../../data/writing_pronouns.js');
        console.log('Pronoun hints available:', Object.keys(writingPronouns.hints));
        hintContent = writingPronouns.hints[hintType];
        
        if (!hintContent) {
          console.log('æœªæ‰¾åˆ°æç¤ºå†…å®¹ï¼ŒhintType:', hintType);
          hintContent = "æš‚æ— æ­¤ç±»å‹çš„æç¤º";
        }
      } else if (firstTableId.startsWith('noun_')) {
        // åè¯åç¼€è¡¨æ ¼
        const writingNouns = require('../../data/writing_nouns.js');
        hintContent = writingNouns.hints[hintType] || "æš‚æ— æ­¤ç±»å‹çš„æç¤º";
      } else if (hintType === "ç°åœ¨åˆ†è¯æ„æˆè§„åˆ™") {
        // ç°åœ¨åˆ†è¯è§„åˆ™
        hintContent = "ç°åœ¨åˆ†è¯æ„æˆè§„åˆ™ï¼š\n1. ä¸€èˆ¬åŠ¨è¯ç›´æ¥åŠ -ing\n2. ä»¥ä¸å‘éŸ³çš„eç»“å°¾ï¼Œå»eåŠ -ing\n3. ä»¥é‡è¯»é—­éŸ³èŠ‚ç»“å°¾ï¼ŒåŒå†™æœ€åä¸€ä¸ªè¾…éŸ³å­—æ¯å†åŠ -ing\n4. ä»¥ieç»“å°¾ï¼Œå˜ieä¸ºyå†åŠ -ing";
      } else if (hintType === "è¿‡å»åˆ†è¯æ„æˆè§„åˆ™") {
        // è¿‡å»åˆ†è¯è§„åˆ™
        hintContent = "è¿‡å»åˆ†è¯æ„æˆè§„åˆ™ï¼š\n1. è§„åˆ™åŠ¨è¯åŠ -ed\n2. ä»¥eç»“å°¾åªåŠ -d\n3. ä»¥è¾…éŸ³å­—æ¯+yç»“å°¾ï¼Œå˜yä¸ºiå†åŠ -ed\n4. é‡è¯»é—­éŸ³èŠ‚åŒå†™æœ€åè¾…éŸ³å­—æ¯å†åŠ -ed\n5. ä¸è§„åˆ™åŠ¨è¯éœ€è¦è®°å¿†";
      } else if (hintType === "æ¯”è¾ƒçº§æ„æˆè§„åˆ™" || hintType === "æœ€é«˜çº§æ„æˆè§„åˆ™") {
        // æ¯”è¾ƒçº§æœ€é«˜çº§è§„åˆ™
        const type = hintType.includes("æ¯”è¾ƒçº§") ? "æ¯”è¾ƒçº§" : "æœ€é«˜çº§";
        const suffix = hintType.includes("æ¯”è¾ƒçº§") ? "-er" : "-est";
        hintContent = `${type}æ„æˆè§„åˆ™ï¼š\n1. å•éŸ³èŠ‚å½¢å®¹è¯ç›´æ¥åŠ ${suffix}\n2. ä»¥eç»“å°¾åªåŠ -ræˆ–-st\n3. ä»¥è¾…éŸ³å­—æ¯+yç»“å°¾ï¼Œå˜yä¸ºiå†åŠ ${suffix}\n4. é‡è¯»é—­éŸ³èŠ‚åŒå†™æœ€åè¾…éŸ³å­—æ¯å†åŠ ${suffix}\n5. å¤šéŸ³èŠ‚ç”¨more/most`;
      } else if (hintType === "å‰¯è¯æ„æˆè§„åˆ™") {
        // å‰¯è¯æ„æˆè§„åˆ™
        hintContent = "å‰¯è¯æ„æˆè§„åˆ™ï¼š\n1. å¤§å¤šæ•°å½¢å®¹è¯ç›´æ¥åŠ -ly\n2. ä»¥yç»“å°¾çš„å½¢å®¹è¯ï¼Œå˜yä¸ºiå†åŠ -ly\n3. ä»¥leç»“å°¾çš„å½¢å®¹è¯ï¼Œå»eåŠ -y\n4. éƒ¨åˆ†å½¢å®¹è¯ä¸å‰¯è¯åŒå½¢\n5. ç‰¹æ®Šå˜åŒ–éœ€è¦è®°å¿†";
      } else {
        // é€šç”¨æç¤º
        hintContent = "è¯·æŸ¥çœ‹å¯¹åº”çš„å­¦ä¹ èµ„æ–™æˆ–è”ç³»è€å¸ˆè·å–æ›´å¤šå¸®åŠ©ã€‚";
      }
    } else {
      hintContent = "æš‚æ— æç¤ºå†…å®¹";
    }
    
    console.log('Final hintContent:', hintContent);
    
    this.setData({
      showHintModal: false,
      showHintContentModal: true,
      hintContent: hintContent
    });
  },

  // å…³é—­æç¤ºå†…å®¹å¼¹çª—
  closeHintContentModal() {
    this.setData({
      showHintContentModal: false
    });
  },

  // ä¿å­˜é”™é¢˜åˆ°æœ¬åœ°å­˜å‚¨ï¼ˆæ–°å¢è‡ªåŠ¨ç§»é™¤é€»è¾‘ï¼‰
  saveWrongQuestions(wrongQuestions) {
    try {
      const existingWrongQuestions = wx.getStorageSync('wrongQuestions') || [];
      const removedWrongQuestions = wx.getStorageSync('removedWrongQuestions') || [];
      
      // ä¸ºæ¯ä¸ªé”™é¢˜æ·»åŠ æ—¶é—´æˆ³å’Œåˆ†ç±»ä¿¡æ¯
      const newWrongQuestions = wrongQuestions.map(wrongQ => {
        // æ­£ç¡®æå–é¢˜ç›®å†…å®¹
        let questionText = '';
        if (typeof wrongQ.question === 'string') {
          questionText = wrongQ.question;
        } else if (typeof wrongQ.question === 'object' && wrongQ.question) {
          questionText = wrongQ.question.question || wrongQ.question.text || JSON.stringify(wrongQ.question);
        } else {
          questionText = 'æœªçŸ¥é¢˜ç›®';
        }
        
        // åˆ›å»ºåŒ…å«ç­”æ¡ˆä¿¡æ¯çš„é¢˜ç›®å¯¹è±¡ç”¨äºåˆ†ç±»
        const questionWithAnswer = {
          question: questionText,
          answer: wrongQ.correctAnswer,
          userAnswer: wrongQ.userAnswer,
          tag: wrongQ.tag || wrongQ.category, // ä¼˜å…ˆä½¿ç”¨tagï¼Œå¦åˆ™ä½¿ç”¨category
          category: wrongQ.category // ä¸´æ—¶ä¿ç•™ç”¨äºæ˜ å°„
        };
        
        return {
          id: Date.now() + Math.random(),
          question: questionText,
          userAnswer: wrongQ.userAnswer,
          correctAnswer: wrongQ.correctAnswer,
          analysis: wrongQ.analysis || '', // æ–°å¢ï¼šè§£æä¿¡æ¯
          tag: wrongQ.tag || wrongQ.category, // ä¿å­˜åŸå§‹åˆ†ç±»
          category: this.getCategoryFromQuestion(questionWithAnswer), // ä½¿ç”¨æ˜ å°„åçš„åˆ†ç±»
          timestamp: new Date().toISOString(),
          date: new Date().toLocaleDateString(),
          correctCount: 0, // æ–°å¢ï¼šæ­£ç¡®æ¬¡æ•°è®¡æ•°
          errorCount: 1 // æ–°å¢ï¼šé”™è¯¯æ¬¡æ•°è®¡æ•°
        };
      });
      
      // æ£€æŸ¥æ˜¯å¦æœ‰é‡å¤é”™é¢˜ï¼Œæ›´æ–°è®¡æ•°
      const updatedWrongQuestions = [];
      const questionsToRemove = [];
      
      // å¤„ç†ç°æœ‰é”™é¢˜
      existingWrongQuestions.forEach(existingQ => {
        const isDuplicate = newWrongQuestions.some(newQ => 
          newQ.question === existingQ.question && newQ.correctAnswer === existingQ.correctAnswer
        );
        
        if (isDuplicate) {
          // æ‰¾åˆ°é‡å¤çš„é”™é¢˜ï¼Œå¢åŠ é”™è¯¯è®¡æ•°
          const duplicateNewQ = newWrongQuestions.find(newQ => 
            newQ.question === existingQ.question && newQ.correctAnswer === existingQ.correctAnswer
          );
          
          const updatedQ = {
            ...existingQ,
            errorCount: (existingQ.errorCount || 0) + 1,
            timestamp: new Date().toISOString(),
            date: new Date().toLocaleDateString()
          };
          
          updatedWrongQuestions.push(updatedQ);
          
          // ä»æ–°é”™é¢˜åˆ—è¡¨ä¸­ç§»é™¤é‡å¤é¡¹
          const newQIndex = newWrongQuestions.findIndex(newQ => 
            newQ.question === existingQ.question && newQ.correctAnswer === existingQ.correctAnswer
          );
          if (newQIndex !== -1) {
            newWrongQuestions.splice(newQIndex, 1);
          }
        } else {
          updatedWrongQuestions.push(existingQ);
        }
      });
      
      // æ·»åŠ æ–°çš„é”™é¢˜
      updatedWrongQuestions.push(...newWrongQuestions);
      
      // æ£€æŸ¥è‡ªåŠ¨ç§»é™¤æ¡ä»¶
      const autoRemoveConfig = wx.getStorageSync('autoRemoveConfig') || { enabled: true, correctCount: 3 };
      
      if (autoRemoveConfig.enabled) {
        updatedWrongQuestions.forEach((question, index) => {
          if (question.correctCount >= autoRemoveConfig.correctCount) {
            // è¾¾åˆ°ç§»é™¤æ¡ä»¶ï¼Œç§»åŠ¨åˆ°å·²ç§»é™¤åˆ—è¡¨
            const removedQuestion = {
              ...question,
              removedReason: {
                correctCount: question.correctCount,
                autoRemove: true
              },
              removedDate: new Date().toLocaleDateString()
            };
            
            questionsToRemove.push(index);
            removedWrongQuestions.push(removedQuestion);
          }
        });
        
        // ä»é”™é¢˜æœ¬ä¸­ç§»é™¤è¾¾åˆ°æ¡ä»¶çš„é”™é¢˜
        questionsToRemove.reverse().forEach(index => {
          updatedWrongQuestions.splice(index, 1);
        });
      }
      
      // é™åˆ¶é”™é¢˜æ€»æ•°ï¼Œé¿å…å­˜å‚¨è¿‡å¤šï¼ˆæœ€å¤šä¿ç•™500é¢˜ï¼‰
      const limitedWrongQuestions = updatedWrongQuestions.slice(-500);
      
      wx.setStorageSync('wrongQuestions', limitedWrongQuestions);
      wx.setStorageSync('removedWrongQuestions', removedWrongQuestions);
      
      console.log('é”™é¢˜å·²ä¿å­˜:', newWrongQuestions.length, 'é¢˜');
      if (questionsToRemove.length > 0) {
        console.log('è‡ªåŠ¨ç§»é™¤é”™é¢˜:', questionsToRemove.length, 'é¢˜');
      }
    } catch (error) {
      console.error('ä¿å­˜é”™é¢˜å¤±è´¥:', error);
    }
  },

  // ä¿å­˜ç»ƒä¹ è®°å½•
  savePracticeHistory(record) {
    try {
      const existingHistory = wx.getStorageSync('practiceHistory') || [];
      
      const newRecord = {
        id: Date.now(),
        ...record,
        timestamp: new Date().toISOString()
      };
      
      // æ·»åŠ æ–°è®°å½•
      const allHistory = [...existingHistory, newRecord];
      
      // é™åˆ¶è®°å½•æ€»æ•°ï¼ˆæœ€å¤šä¿ç•™100æ¡ï¼‰
      const limitedHistory = allHistory.slice(-100);
      
      wx.setStorageSync('practiceHistory', limitedHistory);
      console.log('ç»ƒä¹ è®°å½•å·²ä¿å­˜:', newRecord);
    } catch (error) {
      console.error('ä¿å­˜ç»ƒä¹ è®°å½•å¤±è´¥:', error);
    }
  },

  // æ–°å¢ï¼šæ›´æ–°é”™é¢˜æ­£ç¡®æ¬¡æ•°ï¼ˆå½“ç”¨æˆ·åšå¯¹é¢˜ç›®æ—¶è°ƒç”¨ï¼‰
  updateWrongQuestionCorrectCount(correctQuestions) {
    try {
      const existingWrongQuestions = wx.getStorageSync('wrongQuestions') || [];
      const removedWrongQuestions = wx.getStorageSync('removedWrongQuestions') || [];
      const autoRemoveConfig = wx.getStorageSync('autoRemoveConfig') || { enabled: true, correctCount: 3 };
      
      const updatedWrongQuestions = [];
      const questionsToRemove = [];
      
      console.log('å¼€å§‹æ›´æ–°é”™é¢˜æ­£ç¡®æ¬¡æ•°:', correctQuestions.length, 'é“æ­£ç¡®é¢˜ç›®');
      console.log('é”™é¢˜æ¶ˆç­ç»ƒä¹ æ¨¡å¼:', this.data.isWrongQuestionElimination);
      
      existingWrongQuestions.forEach(question => {
        // æ”¹è¿›é¢˜ç›®åŒ¹é…é€»è¾‘
        const isCorrect = correctQuestions.some(correctQ => {
          // è·å–é¢˜ç›®æ–‡æœ¬
          const correctQText = correctQ.question || correctQ.text || correctQ;
          const questionText = question.question;
          
          // è·å–æ­£ç¡®ç­”æ¡ˆ
          const correctQAnswer = correctQ.answer || correctQ.correctAnswer;
          const questionAnswer = question.correctAnswer;
          
          console.log('é¢˜ç›®åŒ¹é…æ¯”è¾ƒ:', {
            correctQText: correctQText.substring(0, 50),
            questionText: questionText.substring(0, 50),
            correctQAnswer,
            questionAnswer,
            correctQId: correctQ.id,
            questionId: question.id
          });
          
          // å¦‚æœæœ‰IDå­—æ®µï¼Œä¼˜å…ˆä½¿ç”¨IDåŒ¹é…ï¼ˆé€‚ç”¨äºé”™é¢˜æ¶ˆç­ç»ƒä¹ ï¼‰
          if (correctQ.id && question.id) {
            const idMatch = correctQ.id === question.id;
            console.log('IDåŒ¹é…ç»“æœ:', idMatch);
            return idMatch;
          }
          
          // å¦åˆ™ä½¿ç”¨é¢˜ç›®æ–‡æœ¬å’Œç­”æ¡ˆåŒ¹é…
          const textMatch = correctQText === questionText && correctQAnswer === questionAnswer;
          console.log('æ–‡æœ¬åŒ¹é…ç»“æœ:', textMatch);
          return textMatch;
        });
        
        if (isCorrect) {
          // ç”¨æˆ·åšå¯¹äº†è¿™é“é”™é¢˜ï¼Œå¢åŠ æ­£ç¡®æ¬¡æ•°
          const updatedQuestion = {
            ...question,
            correctCount: (question.correctCount || 0) + 1
          };
          
          console.log(`é¢˜ç›® "${question.question}" æ­£ç¡®æ¬¡æ•°æ›´æ–°ä¸º: ${updatedQuestion.correctCount}`);
          
          // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°è‡ªåŠ¨ç§»é™¤æ¡ä»¶
          if (autoRemoveConfig.enabled && updatedQuestion.correctCount >= autoRemoveConfig.correctCount) {
            // è¾¾åˆ°ç§»é™¤æ¡ä»¶ï¼Œç§»åŠ¨åˆ°å·²ç§»é™¤åˆ—è¡¨
            const removedQuestion = {
              ...updatedQuestion,
              removedReason: {
                correctCount: updatedQuestion.correctCount,
                autoRemove: true
              },
              removedDate: new Date().toLocaleDateString()
            };
            
            questionsToRemove.push(removedQuestion);
            console.log(`é¢˜ç›® "${question.question}" è¾¾åˆ°ç§»é™¤æ¡ä»¶ï¼Œæ­£ç¡®æ¬¡æ•°: ${updatedQuestion.correctCount}`);
          } else {
            updatedWrongQuestions.push(updatedQuestion);
          }
        } else {
          updatedWrongQuestions.push(question);
        }
      });
      
      // æ›´æ–°å·²ç§»é™¤é”™é¢˜åˆ—è¡¨
      const updatedRemovedWrongQuestions = [...removedWrongQuestions, ...questionsToRemove];
      
      // ä¿å­˜æ›´æ–°åçš„æ•°æ®
      wx.setStorageSync('wrongQuestions', updatedWrongQuestions);
      wx.setStorageSync('removedWrongQuestions', updatedRemovedWrongQuestions);
      
      if (questionsToRemove.length > 0) {
        console.log('è‡ªåŠ¨ç§»é™¤é”™é¢˜:', questionsToRemove.length, 'é¢˜');
        wx.showToast({
          title: `${questionsToRemove.length}é“é”™é¢˜å·²è‡ªåŠ¨ç§»é™¤`,
          icon: 'none',
          duration: 2000
        });
      }
      
      // å¦‚æœæ˜¯é”™é¢˜æ¶ˆç­ç»ƒä¹ ï¼Œæ˜¾ç¤ºç‰¹æ®Šæç¤º
      if (this.data.isWrongQuestionElimination) {
        const updatedCount = correctQuestions.length;
        if (updatedCount > 0) {
          setTimeout(() => {
            wx.showModal({
              title: 'é”™é¢˜æ¶ˆç­è¿›åº¦',
              content: `æœ¬æ¬¡ç»ƒä¹ ä¸­æ‚¨åšå¯¹äº†${updatedCount}é“é”™é¢˜ï¼Œè¿™äº›é¢˜ç›®çš„æ­£ç¡®æ¬¡æ•°å·²æ›´æ–°ã€‚\n\nç»§ç»­ç»ƒä¹ ï¼Œè¾¾åˆ°è®¾å®šæ¬¡æ•°åé”™é¢˜å°†è‡ªåŠ¨ç§»é™¤ï¼`,
              showCancel: false,
              confirmText: 'çŸ¥é“äº†'
            });
          }, 2500);
        }
      }
      
      console.log('é”™é¢˜æ­£ç¡®æ¬¡æ•°æ›´æ–°å®Œæˆ');
      
    } catch (error) {
      console.error('æ›´æ–°é”™é¢˜æ­£ç¡®æ¬¡æ•°å¤±è´¥:', error);
    }
  },

  // ä»é¢˜ç›®è·å–åˆ†ç±»ä¿¡æ¯ï¼ˆä¿®å¤ç‰ˆ - åŸºäºç²¾ç¡®ç­”æ¡ˆåŒ¹é…ï¼‰
  getCategoryFromQuestion(question) {
    // ä¼˜å…ˆä½¿ç”¨tagè¿›è¡Œæ˜ å°„
    if (typeof question === 'object' && question.tag) {
      const categoryMapping = {
        // ä»‹è¯ç›¸å…³åˆ†ç±»
        "ä»‹è¯ï¼ˆ1ï¼‰": "ä»‹è¯", "ä»‹è¯ï¼ˆ2ï¼‰": "ä»‹è¯", "ä»‹è¯ï¼ˆ3ï¼‰": "ä»‹è¯",
        // ä»£è¯ç›¸å…³åˆ†ç±»
        "ä»£è¯ï¼ˆ1ï¼‰": "ä»£è¯", "ä»£è¯ï¼ˆ2ï¼‰": "ä»£è¯", "ä»£è¯ï¼ˆ3ï¼‰": "ä»£è¯", 
        "ä»£è¯ï¼ˆ4ï¼‰": "ä»£è¯", "ä»£è¯ï¼ˆ5ï¼‰": "ä»£è¯", "ä»£è¯ï¼ˆ6ï¼‰": "ä»£è¯",
        // è¿è¯ç›¸å…³åˆ†ç±»
        "è¿è¯ï¼ˆ1ï¼‰": "è¿è¯", "è¿è¯ï¼ˆ2ï¼‰": "è¿è¯", "è¿è¯ï¼ˆ3ï¼‰": "è¿è¯",
        "è¿è¯ï¼ˆ4ï¼‰": "è¿è¯", "è¿è¯ï¼ˆ5ï¼‰": "è¿è¯", "è¿è¯ï¼ˆ6ï¼‰": "è¿è¯",
        "è¿è¯ä¸åè¯": "è¿è¯", "è¿è¯ä¸åŠ¨è¯": "è¿è¯", "è¿è¯ä¸å½¢å®¹è¯": "è¿è¯",
        "è¿è¯ä¸å/åŠ¨/å½¢/å‰¯ç»¼åˆ": "è¿è¯", "å¹¶åˆ—è¿è¯ç»¼åˆ": "è¿è¯", "ä»å±è¿è¯ç»¼åˆ": "è¿è¯",
        // å† è¯ç›¸å…³åˆ†ç±»
        "å† è¯ï¼ˆ1ï¼‰": "å† è¯", "å† è¯ï¼ˆ2ï¼‰": "å† è¯", "å† è¯ï¼ˆ3ï¼‰": "å† è¯", "å† è¯ï¼ˆ4ï¼‰": "å† è¯",
        // åè¯ç›¸å…³åˆ†ç±»
        "åè¯ï¼ˆ1ï¼‰": "åè¯", "åè¯ï¼ˆ2ï¼‰": "åè¯", "åè¯ï¼ˆ3ï¼‰": "åè¯", 
        "åè¯ï¼ˆ4ï¼‰": "åè¯", "åè¯ï¼ˆ5ï¼‰": "åè¯", "åè¯ï¼ˆ6ï¼‰": "åè¯",
        // åŠ¨è¯ç›¸å…³åˆ†ç±»
        "åŠ¨è¯ï¼ˆ1ï¼‰": "åŠ¨è¯", "åŠ¨è¯ï¼ˆ2ï¼‰": "åŠ¨è¯", "åŠ¨è¯ï¼ˆ3ï¼‰": "åŠ¨è¯", 
        "åŠ¨è¯ï¼ˆ4ï¼‰": "åŠ¨è¯", "åŠ¨è¯ï¼ˆ5ï¼‰": "åŠ¨è¯",
        // è°“è¯­ç›¸å…³åˆ†ç±»
        "è°“è¯­ï¼ˆ1ï¼‰": "è°“è¯­", "è°“è¯­ï¼ˆ2ï¼‰": "è°“è¯­", "è°“è¯­ï¼ˆ3ï¼‰": "è°“è¯­", 
        "è°“è¯­ï¼ˆ4ï¼‰": "è°“è¯­", "è°“è¯­ï¼ˆ5ï¼‰": "è°“è¯­", "è°“è¯­ï¼ˆ6ï¼‰": "è°“è¯­", "è°“è¯­ï¼ˆ7ï¼‰": "è°“è¯­",
        "è°“è¯­ï¼ˆ8ï¼‰": "è°“è¯­", "è°“è¯­ï¼ˆ9ï¼‰": "è°“è¯­",
        // éè°“è¯­ç›¸å…³åˆ†ç±»
        "éè°“è¯­ï¼ˆ1ï¼‰": "éè°“è¯­", "éè°“è¯­ï¼ˆ2ï¼‰": "éè°“è¯­", "éè°“è¯­ï¼ˆ3ï¼‰": "éè°“è¯­", "éè°“è¯­ï¼ˆ4ï¼‰": "éè°“è¯­",
        // å½¢å®¹è¯ç›¸å…³åˆ†ç±»
        "å½¢å®¹è¯ï¼ˆ1ï¼‰": "å½¢å®¹è¯", "å½¢å®¹è¯ï¼ˆ2ï¼‰": "å½¢å®¹è¯", "å½¢å®¹è¯ï¼ˆ3ï¼‰": "å½¢å®¹è¯",
        // å‰¯è¯ç›¸å…³åˆ†ç±»
        "å‰¯è¯ï¼ˆ1ï¼‰": "å‰¯è¯", "å‰¯è¯ï¼ˆ2ï¼‰": "å‰¯è¯", "å‰¯è¯ï¼ˆ3ï¼‰": "å‰¯è¯", "å‰¯è¯ï¼ˆ4ï¼‰": "å‰¯è¯",
        // å®šè¯­ä»å¥ç›¸å…³åˆ†ç±»
        "å®šè¯­ä»å¥ï¼ˆ1ï¼‰": "å®šè¯­ä»å¥", "å®šè¯­ä»å¥ï¼ˆ2ï¼‰": "å®šè¯­ä»å¥", "å®šè¯­ä»å¥ï¼ˆ3ï¼‰": "å®šè¯­ä»å¥",
        "å®šè¯­ä»å¥ï¼ˆ4ï¼‰": "å®šè¯­ä»å¥", "å®šè¯­ä»å¥ï¼ˆ5ï¼‰": "å®šè¯­ä»å¥",
        // çŠ¶è¯­ä»å¥ç›¸å…³åˆ†ç±»
        "çŠ¶è¯­å’Œä»å¥ï¼ˆ1ï¼‰": "çŠ¶è¯­ä»å¥", "çŠ¶è¯­å’Œä»å¥ï¼ˆ2ï¼‰": "çŠ¶è¯­ä»å¥", "çŠ¶è¯­å’Œä»å¥ï¼ˆ3ï¼‰": "çŠ¶è¯­ä»å¥",
        "çŠ¶è¯­å’Œä»å¥ï¼ˆ4ï¼‰": "çŠ¶è¯­ä»å¥", "çŠ¶è¯­å’Œä»å¥ï¼ˆ5ï¼‰": "çŠ¶è¯­ä»å¥"
      };
      
      return categoryMapping[question.category] || question.category;
    }
    
    // è·å–é¢˜ç›®æ–‡æœ¬å’Œç­”æ¡ˆ
    const questionText = typeof question === 'string' ? question : (question.question || '');
    const answer = typeof question === 'object' ? question.answer : '';
    const analysis = typeof question === 'object' ? question.analysis || '' : '';
    const lowerText = questionText.toLowerCase();
    const lowerAnswer = answer.toLowerCase().trim();
    const lowerAnalysis = analysis.toLowerCase();
    
    console.log(`[åˆ†ç±»è°ƒè¯•] é¢˜ç›®: "${questionText}", ç­”æ¡ˆ: "${answer}"`);
    
    // === ä¿®å¤ï¼šæŒ‰ä¼˜å…ˆçº§è¿›è¡Œåˆ†ç±»åˆ¤æ–­ ===
    
    // 1. å† è¯ç±»ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼Œå› ä¸ºè¯æ±‡æœ‰é™ï¼‰
    if (['a', 'an', 'the'].includes(lowerAnswer)) {
      console.log(`[åˆ†ç±»è°ƒè¯•] å† è¯åŒ¹é…æˆåŠŸ: ${lowerAnswer}`);
      return 'å† è¯';
    }
    
    // 2. ä»£è¯ç±»
    const pronounPatterns = [
      // äººç§°ä»£è¯
      'i', 'me', 'you', 'he', 'him', 'she', 'her', 'it', 'we', 'us', 'they', 'them',
      // ç‰©ä¸»ä»£è¯
      'my', 'your', 'his', 'her', 'its', 'our', 'their',
      'mine', 'yours', 'hers', 'ours', 'theirs',
      // åèº«ä»£è¯
      'myself', 'yourself', 'himself', 'herself', 'itself', 'ourselves', 'yourselves', 'themselves',
      // æŒ‡ç¤ºä»£è¯
      'this', 'that', 'these', 'those',
      // å…³ç³»ä»£è¯
      'who', 'whom', 'whose', 'which', 'what'
    ];
    
    if (pronounPatterns.includes(lowerAnswer)) {
      console.log(`[åˆ†ç±»è°ƒè¯•] ä»£è¯åŒ¹é…æˆåŠŸ: ${lowerAnswer}`);
      return 'ä»£è¯';
    }
    
    // 3. ä»‹è¯ç±»
    const prepositionPatterns = [
      'in', 'on', 'at', 'for', 'with', 'by', 'from', 'to', 'of', 'about', 
      'against', 'among', 'between', 'during', 'except', 'into', 'like', 
      'near', 'over', 'since', 'through', 'under', 'until', 'upon', 
      'within', 'without', 'above', 'below', 'beside', 'beyond', 'across',
      'behind', 'before', 'after', 'inside', 'outside', 'along', 'around'
    ];
    
    if (prepositionPatterns.includes(lowerAnswer)) {
      console.log(`[åˆ†ç±»è°ƒè¯•] ä»‹è¯åŒ¹é…æˆåŠŸ: ${lowerAnswer}`);
      return 'ä»‹è¯';
    }
    
    // 4. è¿è¯ç±»
    const conjunctionPatterns = [
      // å¹¶åˆ—è¿è¯
      'and', 'but', 'or', 'nor', 'for', 'so', 'yet',
      // ä»å±è¿è¯
      'because', 'since', 'as', 'when', 'while', 'where', 'if', 'unless', 
      'although', 'though', 'however', 'therefore', 'moreover', 'furthermore',
      'before', 'after', 'until', 'whether', 'that',
      // ç–‘é—®è¯ï¼ˆå¸¸ç”¨ä½œè¿è¯ï¼‰
      'why', 'how', 'what', 'when', 'where'
    ];
    
    if (conjunctionPatterns.includes(lowerAnswer)) {
      console.log(`[åˆ†ç±»è°ƒè¯•] è¿è¯åŒ¹é…æˆåŠŸ: ${lowerAnswer}`);
      return 'è¿è¯';
    }
    
    // 5. å½¢å®¹è¯ç±»ï¼ˆåŒ…æ‹¬æ¯”è¾ƒçº§ã€æœ€é«˜çº§ï¼‰
    const adjectivePatterns = [
      // æœ€é«˜çº§
      'biggest', 'smallest', 'fastest', 'slowest', 'tallest', 'shortest',
      'best', 'worst', 'most', 'least', 'happiest', 'saddest', 'busiest', 'easiest',
      'funniest', 'prettiest', 'ugliest', 'smartest', 'kindest', 'hardest',
      'largest', 'greatest', 'strongest', 'weakest', 'richest', 'poorest',
      'youngest', 'oldest', 'newest', 'oldest', 'cleanest', 'dirtiest',
      'safest', 'dangerous', 'healthiest', 'sickest', 'freshest', 'stale',
      // æ¯”è¾ƒçº§
      'bigger', 'smaller', 'faster', 'slower', 'taller', 'shorter',
      'better', 'worse', 'more', 'less', 'happier', 'sadder', 'busier', 'easier',
      'funnier', 'prettier', 'uglier', 'smarter', 'kinder', 'harder',
      'larger', 'greater', 'stronger', 'weaker', 'richer', 'poorer',
      'younger', 'older', 'newer', 'cleaner', 'dirtier', 'safer', 'healthier',
      'fresher', 'sweeter', 'bitter', 'warmer', 'colder', 'hotter', 'cooler',
      // æ™®é€šå½¢å®¹è¯
      'good', 'bad', 'big', 'small', 'fast', 'slow', 'tall', 'short', 'lazy', 'busy',
      'happy', 'sad', 'easy', 'difficult', 'hard', 'soft', 'hot', 'cold', 'warm', 'cool',
      'funny', 'pretty', 'ugly', 'smart', 'kind', 'nice', 'beautiful', 'interesting',
      'large', 'great', 'strong', 'weak', 'rich', 'poor', 'young', 'old', 'new',
      'clean', 'dirty', 'safe', 'dangerous', 'healthy', 'sick', 'fresh', 'stale',
      'sweet', 'bitter', 'sour', 'spicy', 'salty', 'delicious', 'tasty', 'awful',
      'wonderful', 'amazing', 'terrible', 'excellent', 'perfect', 'awful', 'horrible',
      'lovely', 'wonderful', 'fantastic', 'brilliant', 'clever', 'stupid', 'foolish',
      'wise', 'brave', 'cowardly', 'honest', 'dishonest', 'polite', 'rude', 'friendly',
      'unfriendly', 'generous', 'selfish', 'patient', 'impatient', 'careful', 'careless',
      'quiet', 'noisy', 'loud', 'silent', 'bright', 'dark', 'light', 'heavy', 'light',
      'thick', 'thin', 'wide', 'narrow', 'long', 'short', 'high', 'low', 'deep', 'shallow',
      'full', 'empty', 'open', 'closed', 'free', 'busy', 'available', 'unavailable',
      'possible', 'impossible', 'necessary', 'unnecessary', 'important', 'unimportant',
      'special', 'ordinary', 'normal', 'strange', 'usual', 'unusual', 'common', 'rare',
      'simple', 'complex', 'easy', 'hard', 'difficult', 'simple', 'complicated'
    ];
    
    // æ£€æŸ¥å½¢å®¹è¯ï¼ˆåŒ…æ‹¬åç¼€åˆ¤æ–­ï¼‰
    if (adjectivePatterns.includes(lowerAnswer) || 
        lowerAnswer.endsWith('est') || 
        lowerAnswer.endsWith('er') ||
        lowerAnswer.endsWith('ful') || 
        lowerAnswer.endsWith('less') || 
        lowerAnswer.endsWith('ous') ||
        lowerAnswer.endsWith('ive') ||
        lowerAnswer.endsWith('able') ||
        lowerAnswer.endsWith('ible')) {
      console.log(`[åˆ†ç±»è°ƒè¯•] å½¢å®¹è¯åŒ¹é…æˆåŠŸ: ${lowerAnswer}`);
      return 'å½¢å®¹è¯';
    }
    
    // 6. å‰¯è¯ç±»
    const adverbPatterns = [
      'quickly', 'slowly', 'carefully', 'easily', 'hardly', 'really', 'very', 'quite',
      'often', 'always', 'never', 'sometimes', 'usually', 'seldom', 'frequently',
      'well', 'badly', 'fast', 'slow', 'early', 'late', 'soon', 'now', 'then',
      'here', 'there', 'everywhere', 'nowhere', 'somewhere', 'anywhere',
      'today', 'yesterday', 'tomorrow', 'immediately', 'suddenly', 'finally'
    ];
    
    // æ£€æŸ¥å‰¯è¯ï¼ˆåŒ…æ‹¬-lyåç¼€ï¼Œä½†æ’é™¤ä¸€äº›ç‰¹æ®Šæƒ…å†µï¼‰
    if (adverbPatterns.includes(lowerAnswer) || 
        (lowerAnswer.endsWith('ly') && !['early', 'daily', 'monthly', 'yearly', 'family', 'lovely', 'lonely', 'likely'].includes(lowerAnswer))) {
      console.log(`[åˆ†ç±»è°ƒè¯•] å‰¯è¯åŒ¹é…æˆåŠŸ: ${lowerAnswer}`);
      return 'å‰¯è¯';
    }
    
    // 7. åè¯ç±»ï¼ˆåŒ…æ‹¬å¤æ•°å½¢å¼ï¼‰
    const nounPatterns = [
      // å¸¸è§åè¯å¤æ•°
      'books', 'students', 'teachers', 'children', 'people', 'friends', 'families',
      'houses', 'cars', 'dogs', 'cats', 'trees', 'flowers', 'schools', 'hospitals',
      'churches', 'boxes', 'glasses', 'dishes', 'watches', 'buses', 'classes',
      'stories', 'cities', 'countries', 'companies', 'parties', 'babies', 'ladies',
      'men', 'women', 'feet', 'teeth', 'mice', 'geese', 'sheep', 'deer',
      'knives', 'lives', 'wives', 'leaves', 'thieves', 'wolves', 'halves',
      'potatoes', 'tomatoes', 'heroes', 'echoes', 'volcanoes', 'pianos', 'photos',
      'radios', 'zoos', 'kangaroos', 'bamboos', 'studios', 'videos',
      // å¸¸è§åè¯å•æ•°
      'book', 'student', 'teacher', 'child', 'person', 'friend', 'family',
      'house', 'car', 'dog', 'cat', 'tree', 'flower', 'school', 'hospital',
      'church', 'box', 'glass', 'dish', 'watch', 'bus', 'class',
      'story', 'city', 'country', 'company', 'party', 'baby', 'lady',
      'man', 'woman', 'foot', 'tooth', 'mouse', 'goose', 'sheep', 'deer',
      'knife', 'life', 'wife', 'leaf', 'thief', 'wolf', 'half',
      'potato', 'tomato', 'hero', 'echo', 'volcano', 'piano', 'photo',
      'radio', 'zoo', 'kangaroo', 'bamboo', 'studio', 'video'
    ];
    
    // æ£€æŸ¥åè¯ï¼ˆåŒ…æ‹¬å¤æ•°åˆ¤æ–­ï¼‰
    if (nounPatterns.includes(lowerAnswer) || 
        (lowerAnswer.endsWith('s') && !['yes', 'this', 'his', 'its', 'us', 'as', 'was', 'has', 'does', 'says', 'goes', 'comes', 'takes', 'makes', 'gives', 'sees', 'knows', 'thinks', 'works', 'lives', 'gets', 'puts', 'wants', 'needs', 'likes', 'loves', 'hates', 'plays', 'reads', 'writes', 'speaks', 'talks', 'walks', 'runs', 'eats', 'drinks', 'sleeps', 'wakes', 'buys', 'sells', 'finds', 'keeps', 'brings', 'sends', 'shows', 'tells', 'asks', 'answers', 'calls', 'meets', 'helps', 'starts', 'stops', 'opens', 'closes', 'moves', 'changes', 'turns', 'looks', 'feels', 'sounds', 'smells', 'tastes', 'seems', 'appears', 'becomes', 'remains', 'stays', 'leaves', 'arrives', 'returns', 'reaches', 'passes', 'crosses', 'follows', 'leads', 'carries', 'holds', 'catches', 'throws', 'catches', 'catches', 'catches'].includes(lowerAnswer) && 
         (lowerText.includes('å¤æ•°') || lowerText.includes('plural') || lowerText.includes('noun') || lowerText.includes('åè¯')))) {
      console.log(`[åˆ†ç±»è°ƒè¯•] åè¯åŒ¹é…æˆåŠŸ: ${lowerAnswer}`);
      return 'åè¯';
    }
    
    // 8. åŠ¨è¯ç±»ï¼ˆåŒ…æ‹¬æ—¶æ€ã€è¯­æ€ã€éè°“è¯­ï¼‰
    const verbPatterns = [
      // ç°åœ¨åˆ†è¯/åŠ¨åè¯
      'helping', 'cooking', 'running', 'working', 'playing', 'reading', 'writing', 'swimming',
      'studying', 'living', 'talking', 'walking', 'eating', 'drinking', 'sleeping', 'thinking',
      'remembering', 'learning', 'teaching', 'singing', 'dancing', 'watching', 'listening',
      'speaking', 'looking', 'feeling', 'sounding', 'smelling', 'tasting', 'seeming', 'appearing',
      'becoming', 'remaining', 'staying', 'leaving', 'arriving', 'returning', 'reaching',
      'passing', 'crossing', 'following', 'leading', 'carrying', 'holding', 'catching', 'throwing',
      'buying', 'selling', 'finding', 'keeping', 'bringing', 'sending', 'showing', 'telling',
      'asking', 'answering', 'calling', 'meeting', 'starting', 'stopping', 'opening', 'closing',
      'moving', 'changing', 'turning', 'getting', 'putting', 'wanting', 'needing', 'liking',
      'loving', 'hating', 'knowing', 'understanding', 'believing', 'hoping', 'wishing', 'expecting',
      // è¿‡å»åˆ†è¯/è¿‡å»å¼
      'cooked', 'worked', 'helped', 'played', 'finished', 'studied', 'lived', 'talked',
      'walked', 'eaten', 'drunk', 'slept', 'thought', 'gone', 'come', 'seen', 'done', 'made',
      'worn', 'taken', 'given', 'written', 'spoken', 'broken', 'chosen', 'frozen',
      'spoken', 'looked', 'felt', 'sounded', 'smelled', 'tasted', 'seemed', 'appeared',
      'became', 'remained', 'stayed', 'left', 'arrived', 'returned', 'reached', 'passed',
      'crossed', 'followed', 'led', 'carried', 'held', 'caught', 'threw', 'bought', 'sold',
      'found', 'kept', 'brought', 'sent', 'showed', 'told', 'asked', 'answered', 'called',
      'met', 'started', 'stopped', 'opened', 'closed', 'moved', 'changed', 'turned', 'got',
      'put', 'wanted', 'needed', 'liked', 'loved', 'hated', 'knew', 'understood', 'believed',
      'hoped', 'wished', 'expected',
      // åŸºæœ¬åŠ¨è¯å½¢å¼
      'get', 'gets', 'got', 'getting',
      'live', 'lives', 'lived', 'living',
      'have', 'has', 'had', 'having',
      'am', 'is', 'are', 'was', 'were', 'be', 'being', 'been',
      'will', 'would', 'shall', 'should',
      'can', 'could', 'may', 'might', 'must',
      'do', 'does', 'did', 'doing', 'done',
      'go', 'goes', 'went', 'going',
      'come', 'comes', 'came', 'coming',
      'see', 'sees', 'saw', 'seeing',
      'take', 'takes', 'took', 'taking',
      'give', 'gives', 'gave', 'giving',
      'make', 'makes', 'made', 'making',
      'wear', 'wears', 'wore', 'wearing',
      'speak', 'speaks', 'spoke', 'speaking',
      'look', 'looks', 'looked', 'looking',
      'feel', 'feels', 'felt', 'feeling',
      'sound', 'sounds', 'sounded', 'sounding',
      'smell', 'smells', 'smelled', 'smelling',
      'taste', 'tastes', 'tasted', 'tasting',
      'seem', 'seems', 'seemed', 'seeming',
      'appear', 'appears', 'appeared', 'appearing',
      'become', 'becomes', 'became', 'becoming',
      'remain', 'remains', 'remained', 'remaining',
      'stay', 'stays', 'stayed', 'staying',
      'leave', 'leaves', 'left', 'leaving',
      'arrive', 'arrives', 'arrived', 'arriving',
      'return', 'returns', 'returned', 'returning',
      'reach', 'reaches', 'reached', 'reaching',
      'pass', 'passes', 'passed', 'passing',
      'cross', 'crosses', 'crossed', 'crossing',
      'follow', 'follows', 'followed', 'following',
      'lead', 'leads', 'led', 'leading',
      'carry', 'carries', 'carried', 'carrying',
      'hold', 'holds', 'held', 'holding',
      'catch', 'catches', 'caught', 'catching',
      'throw', 'throws', 'threw', 'throwing',
      'buy', 'buys', 'bought', 'buying',
      'sell', 'sells', 'sold', 'selling',
      'find', 'finds', 'found', 'finding',
      'keep', 'keeps', 'kept', 'keeping',
      'bring', 'brings', 'brought', 'bringing',
      'send', 'sends', 'sent', 'sending',
      'show', 'shows', 'showed', 'showing',
      'tell', 'tells', 'told', 'telling',
      'ask', 'asks', 'asked', 'asking',
      'answer', 'answers', 'answered', 'answering',
      'call', 'calls', 'called', 'calling',
      'meet', 'meets', 'met', 'meeting',
      'start', 'starts', 'started', 'starting',
      'stop', 'stops', 'stopped', 'stopping',
      'open', 'opens', 'opened', 'opening',
      'close', 'closes', 'closed', 'closing',
      'move', 'moves', 'moved', 'moving',
      'change', 'changes', 'changed', 'changing',
      'turn', 'turns', 'turned', 'turning',
      'put', 'puts', 'put', 'putting',
      'want', 'wants', 'wanted', 'wanting',
      'need', 'needs', 'needed', 'needing',
      'like', 'likes', 'liked', 'liking',
      'love', 'loves', 'loved', 'loving',
      'hate', 'hates', 'hated', 'hating',
      'know', 'knows', 'knew', 'knowing',
      'understand', 'understands', 'understood', 'understanding',
      'believe', 'believes', 'believed', 'believing',
      'hope', 'hopes', 'hoped', 'hoping',
      'wish', 'wishes', 'wished', 'wishing',
      'expect', 'expects', 'expected', 'expecting'
    ];
    
    // æ£€æŸ¥åŠ¨è¯ï¼ˆåŒ…æ‹¬æ—¶æ€çŸ­è¯­ï¼‰
    if (verbPatterns.includes(lowerAnswer) || 
        lowerAnswer.includes('has ') || 
        lowerAnswer.includes('have ') || 
        lowerAnswer.includes('had ') ||
        lowerAnswer.includes('will ') ||
        lowerAnswer.includes('would ') ||
        (lowerAnswer.endsWith('ing') && !['during', 'nothing', 'something', 'anything', 'everything', 'morning', 'evening'].includes(lowerAnswer)) ||
        (lowerAnswer.endsWith('ed') && !['bed', 'red', 'wed', 'used', 'based', 'called'].includes(lowerAnswer))) {
      
      // è¿›ä¸€æ­¥åŒºåˆ†è°“è¯­å’Œéè°“è¯­
      if (lowerAnswer.endsWith('ing') && !lowerAnswer.includes(' ')) {
        console.log(`[åˆ†ç±»è°ƒè¯•] éè°“è¯­åŠ¨è¯åŒ¹é…æˆåŠŸ: ${lowerAnswer}`);
        return 'éè°“è¯­';
      } else if (lowerAnswer.endsWith('ed') && !lowerAnswer.includes(' ')) {
        console.log(`[åˆ†ç±»è°ƒè¯•] éè°“è¯­åŠ¨è¯åŒ¹é…æˆåŠŸ: ${lowerAnswer}`);
        return 'éè°“è¯­';
      } else {
        console.log(`[åˆ†ç±»è°ƒè¯•] åŠ¨è¯åŒ¹é…æˆåŠŸ: ${lowerAnswer}`);
        return 'åŠ¨è¯';
      }
    }
    
    // 9. ç‰¹æ®Šæƒ…å†µï¼šå®Œæˆæ—¶æ€
    if (lowerAnswer.includes('has ') || lowerAnswer.includes('have ') || lowerAnswer.includes('had ')) {
      console.log(`[åˆ†ç±»è°ƒè¯•] è°“è¯­åŠ¨è¯åŒ¹é…æˆåŠŸ: ${lowerAnswer}`);
      return 'è°“è¯­';
    }
    
    // 10. ä¸Šä¸‹æ–‡å…³é”®è¯åŒ¹é…
    const contextKeywords = {
      'å®šè¯­ä»å¥': ['å®šè¯­ä»å¥', 'å®šè¯­', 'that', 'which', 'who', 'whose', 'relative clause'],
      'çŠ¶è¯­ä»å¥': ['çŠ¶è¯­ä»å¥', 'çŠ¶è¯­', 'when', 'where', 'how', 'why', 'because', 'adverbial clause']
    };
    
    for (const [category, keywords] of Object.entries(contextKeywords)) {
      for (const keyword of keywords) {
        if (lowerText.includes(keyword)) {
          console.log(`[åˆ†ç±»è°ƒè¯•] ä¸Šä¸‹æ–‡åŒ¹é…æˆåŠŸ: ${category}`);
          return category;
        }
      }
    }
    
    // === æ–°å¢ï¼šäºŒæ¬¡åˆ†ç±»ä¼˜åŒ– ===
    // å¦‚æœå‰é¢çš„åˆ†ç±»éƒ½å¤±è´¥ï¼Œå°è¯•åŸºäºè§£æå†…å®¹è¿›è¡ŒäºŒæ¬¡åˆ†ç±»
    const refinedCategory = this.performSecondaryClassification(lowerText, lowerAnswer, lowerAnalysis);
    if (refinedCategory && refinedCategory !== 'ç»¼åˆ') {
      console.log(`[åˆ†ç±»è°ƒè¯•] äºŒæ¬¡åˆ†ç±»æˆåŠŸ: ${refinedCategory}`);
      return refinedCategory;
    }
    
    // === æœ€ç»ˆå…œåº•ç­–ç•¥ ===
    console.warn(`[åˆ†ç±»è­¦å‘Š] æ— æ³•å‡†ç¡®åˆ†ç±»çš„é¢˜ç›®:`, {
      question: questionText,
      answer: answer,
      lowerAnswer: lowerAnswer
    });
    
    return 'ç»¼åˆ';
  },

  // æ–°å¢ï¼šäºŒæ¬¡åˆ†ç±»å‡½æ•°
  performSecondaryClassification(questionText, answer, analysis) {
    const allText = `${questionText} ${answer} ${analysis}`.toLowerCase();
    
    // 1. åŸºäºè§£æå…³é”®è¯çš„åˆ†ç±»
    const keywordMapping = {
      // åè¯ç›¸å…³
      'åè¯': ['å¤æ•°', 'åè¯', 'noun', 'å•æ•°', 'å¯æ•°åè¯', 'ä¸å¯æ•°åè¯', 'å¯æ•°', 'ä¸å¯æ•°', 'å¤æ•°å½¢å¼', 'å•æ•°å½¢å¼', 'åè¯å¤æ•°', 'åè¯å•æ•°'],
      // è°“è¯­ç›¸å…³
      'è°“è¯­': ['è°“è¯­', 'æ—¶æ€', 'è¿‡å»æ—¶', 'ç°åœ¨æ—¶', 'å°†æ¥æ—¶', 'å®Œæˆæ—¶', 'è¿›è¡Œæ—¶', 'è¢«åŠ¨è¯­æ€', 'ä¸»åŠ¨è¯­æ€', 'predicate', 'tense', 'è°“è¯­åŠ¨è¯', 'ä¸»å¥', 'ä»å¥', 'ä¸»è°“', 'è°“å®¾'],
      // éè°“è¯­ç›¸å…³
      'éè°“è¯­': ['éè°“è¯­', 'ç°åœ¨åˆ†è¯', 'è¿‡å»åˆ†è¯', 'ä¸å®šå¼', 'åŠ¨åè¯', 'éè°“è¯­åŠ¨è¯', 'participle', 'infinitive', 'gerund', 'åˆ†è¯', 'ä¸å®šå¼', 'åŠ¨åè¯', 'éè°“è¯­å½¢å¼'],
      // å½¢å®¹è¯ç›¸å…³
      'å½¢å®¹è¯': ['å½¢å®¹è¯', 'æ¯”è¾ƒçº§', 'æœ€é«˜çº§', 'ä¿®é¥°åè¯', 'adjective', 'comparative', 'superlative', 'å½¢å®¹è¯æ€§', 'ä¿®é¥°æ€§', 'æ€§è´¨', 'ç‰¹å¾'],
      // å‰¯è¯ç›¸å…³
      'å‰¯è¯': ['å‰¯è¯', 'ä¿®é¥°åŠ¨è¯', 'ä¿®é¥°å½¢å®¹è¯', 'adverb', 'å‰¯è¯æ€§', 'ä¿®é¥°å‰¯è¯', 'ç¨‹åº¦', 'æ–¹å¼', 'æ—¶é—´', 'åœ°ç‚¹'],
      // ä»å¥ç›¸å…³
      'å®šè¯­ä»å¥': ['å®šè¯­ä»å¥', 'å…³ç³»ä»£è¯', 'that', 'which', 'who', 'whose', 'relative clause', 'å®šè¯­', 'ä¿®é¥°', 'é™å®š'],
      'çŠ¶è¯­ä»å¥': ['çŠ¶è¯­ä»å¥', 'æ—¶é—´çŠ¶è¯­', 'æ¡ä»¶çŠ¶è¯­', 'åŸå› çŠ¶è¯­', 'adverbial clause', 'when', 'where', 'how', 'why', 'because', 'if', 'unless', 'although', 'though', 'çŠ¶è¯­', 'æ—¶é—´', 'æ¡ä»¶', 'åŸå› ', 'è®©æ­¥']
    };
    
    // æ£€æŸ¥å…³é”®è¯åŒ¹é…
    for (const [category, keywords] of Object.entries(keywordMapping)) {
      for (const keyword of keywords) {
        if (allText.includes(keyword)) {
          console.log(`[äºŒæ¬¡åˆ†ç±»] å…³é”®è¯åŒ¹é…: ${keyword} -> ${category}`);
          return category;
        }
      }
    }
    
         // 2. åŸºäºç­”æ¡ˆå½¢å¼çš„ç‰¹æ®Šåˆ¤æ–­
     // æ£€æŸ¥ to be done å½¢å¼ï¼ˆè¢«åŠ¨ä¸å®šå¼ï¼‰
     if (answer.includes('to be ') && (answer.includes('ed') || answer.includes('en'))) {
       console.log(`[äºŒæ¬¡åˆ†ç±»] è¢«åŠ¨ä¸å®šå¼åŒ¹é…: ${answer}`);
       return 'éè°“è¯­';
     }
     
     // æ£€æŸ¥ to do å½¢å¼ï¼ˆä¸å®šå¼ï¼‰
     if (answer.startsWith('to ') && !answer.includes('be ')) {
       console.log(`[äºŒæ¬¡åˆ†ç±»] ä¸å®šå¼åŒ¹é…: ${answer}`);
       return 'éè°“è¯­';
     }
     
     // æ£€æŸ¥ be done å½¢å¼ï¼ˆè¢«åŠ¨è¯­æ€ï¼‰
     if (answer.includes('be ') && (answer.includes('ed') || answer.includes('en'))) {
       console.log(`[äºŒæ¬¡åˆ†ç±»] è¢«åŠ¨è¯­æ€åŒ¹é…: ${answer}`);
       return 'è°“è¯­';
     }
     
     // æ£€æŸ¥ have/has/had done å½¢å¼ï¼ˆå®Œæˆæ—¶æ€ï¼‰
     if ((answer.includes('have ') || answer.includes('has ') || answer.includes('had ')) && 
         (answer.includes('ed') || answer.includes('en'))) {
       console.log(`[äºŒæ¬¡åˆ†ç±»] å®Œæˆæ—¶æ€åŒ¹é…: ${answer}`);
       return 'è°“è¯­';
     }
     
     // æ£€æŸ¥ will/would do å½¢å¼ï¼ˆå°†æ¥æ—¶æ€ï¼‰
     if ((answer.includes('will ') || answer.includes('would ')) && !answer.includes('be ')) {
       console.log(`[äºŒæ¬¡åˆ†ç±»] å°†æ¥æ—¶æ€åŒ¹é…: ${answer}`);
       return 'è°“è¯­';
     }
     
     // æ£€æŸ¥ am/is/are doing å½¢å¼ï¼ˆç°åœ¨è¿›è¡Œæ—¶ï¼‰
     if ((answer.includes('am ') || answer.includes('is ') || answer.includes('are ')) && answer.includes('ing')) {
       console.log(`[äºŒæ¬¡åˆ†ç±»] ç°åœ¨è¿›è¡Œæ—¶åŒ¹é…: ${answer}`);
       return 'è°“è¯­';
     }
     
     // æ£€æŸ¥ was/were doing å½¢å¼ï¼ˆè¿‡å»è¿›è¡Œæ—¶ï¼‰
     if ((answer.includes('was ') || answer.includes('were ')) && answer.includes('ing')) {
       console.log(`[äºŒæ¬¡åˆ†ç±»] è¿‡å»è¿›è¡Œæ—¶åŒ¹é…: ${answer}`);
       return 'è°“è¯­';
     }
     
     // æ£€æŸ¥å•ç‹¬çš„ -ing å½¢å¼ï¼ˆç°åœ¨åˆ†è¯/åŠ¨åè¯ï¼‰
     if (answer.endsWith('ing') && !answer.includes(' ')) {
       console.log(`[äºŒæ¬¡åˆ†ç±»] ç°åœ¨åˆ†è¯/åŠ¨åè¯åŒ¹é…: ${answer}`);
       return 'éè°“è¯­';
     }
     
     // æ£€æŸ¥å•ç‹¬çš„ -ed å½¢å¼ï¼ˆè¿‡å»åˆ†è¯/è¿‡å»å¼ï¼‰
     if (answer.endsWith('ed') && !answer.includes(' ') && !['bed', 'red', 'wed', 'used', 'based', 'called'].includes(answer)) {
       console.log(`[äºŒæ¬¡åˆ†ç±»] è¿‡å»åˆ†è¯/è¿‡å»å¼åŒ¹é…: ${answer}`);
       // éœ€è¦è¿›ä¸€æ­¥åˆ¤æ–­æ˜¯è°“è¯­è¿˜æ˜¯éè°“è¯­
       if (analysis.includes('è¿‡å»æ—¶') || analysis.includes('æ—¶æ€') || analysis.includes('è°“è¯­')) {
         return 'è°“è¯­';
       } else if (analysis.includes('è¿‡å»åˆ†è¯') || analysis.includes('éè°“è¯­')) {
         return 'éè°“è¯­';
       }
       // é»˜è®¤ä½œä¸ºè°“è¯­å¤„ç†
       return 'è°“è¯­';
     }
    
         // 3. åŸºäºé¢˜ç›®ç»“æ„çš„åˆ¤æ–­
     // æ£€æŸ¥æ˜¯å¦åŒ…å«æ—¶é—´çŠ¶è¯­ï¼ˆæš—ç¤ºæ—¶æ€ï¼‰
     const timeIndicators = ['yesterday', 'tomorrow', 'now', 'ago', 'last', 'next', 'before', 'after', 'when', 'while', 'since', 'until', 'during', 'already', 'yet', 'just', 'recently', 'lately'];
     for (const indicator of timeIndicators) {
       if (questionText.toLowerCase().includes(indicator)) {
         console.log(`[äºŒæ¬¡åˆ†ç±»] æ—¶é—´æŒ‡ç¤ºè¯åŒ¹é…: ${indicator}`);
         return 'è°“è¯­';
       }
     }
     
     // æ£€æŸ¥æ˜¯å¦åŒ…å«æ¯”è¾ƒç»“æ„
     if (questionText.includes('than') || questionText.includes('more') || questionText.includes('most') || 
         questionText.includes('er') || questionText.includes('est') || questionText.includes('better') || 
         questionText.includes('worse') || questionText.includes('best') || questionText.includes('worst')) {
       console.log(`[äºŒæ¬¡åˆ†ç±»] æ¯”è¾ƒç»“æ„åŒ¹é…`);
       return 'å½¢å®¹è¯';
     }
     
     // æ£€æŸ¥æ˜¯å¦åŒ…å«ä»å¥å¼•å¯¼è¯
     const clauseIndicators = {
       'å®šè¯­ä»å¥': ['that', 'which', 'who', 'whom', 'whose', 'where', 'when'],
       'çŠ¶è¯­ä»å¥': ['when', 'where', 'how', 'why', 'because', 'if', 'unless', 'although', 'though', 'while', 'since', 'until', 'before', 'after', 'as', 'so that', 'in order that']
     };
     
     for (const [clauseType, indicators] of Object.entries(clauseIndicators)) {
       for (const indicator of indicators) {
         if (questionText.toLowerCase().includes(indicator)) {
           console.log(`[äºŒæ¬¡åˆ†ç±»] ä»å¥å¼•å¯¼è¯åŒ¹é…: ${indicator} -> ${clauseType}`);
           return clauseType;
         }
       }
     }
     
     // æ£€æŸ¥æ˜¯å¦åŒ…å«è¢«åŠ¨è¯­æ€ç»“æ„
     if (questionText.includes('by ') || questionText.includes('need ') || questionText.includes('want ') || 
         questionText.includes('require ') || questionText.includes('expect ')) {
       console.log(`[äºŒæ¬¡åˆ†ç±»] è¢«åŠ¨è¯­æ€ç»“æ„åŒ¹é…`);
       return 'è°“è¯­';
     }
     
     // æ£€æŸ¥æ˜¯å¦åŒ…å«æƒ…æ€åŠ¨è¯
     const modalVerbs = ['can', 'could', 'may', 'might', 'will', 'would', 'shall', 'should', 'must', 'need', 'dare'];
     for (const modal of modalVerbs) {
       if (answer.includes(modal)) {
         console.log(`[äºŒæ¬¡åˆ†ç±»] æƒ…æ€åŠ¨è¯åŒ¹é…: ${modal}`);
         return 'è°“è¯­';
       }
     }
    
    return null; // è¿”å›nullè¡¨ç¤ºäºŒæ¬¡åˆ†ç±»ä¹Ÿå¤±è´¥
  },

  // æµ‹è¯•åˆ†ç±»ç®—æ³•å‡†ç¡®æ€§
  testCategoryClassification() {
    const testCases = [
      { question: 'There are some ___ (church) in this small town.', answer: 'churches', expected: 'åè¯', analysis: 'è¯¥é¢˜è€ƒæŸ¥åè¯å¤æ•°å½¢å¼ï¼Œchurchçš„å¤æ•°å½¢å¼æ˜¯churches' },
      { question: '___ (remember) seeing a breathtaking dance performance in Beijing, she decided to learn more about traditional Chinese dance.', answer: 'Remembering', expected: 'éè°“è¯­', analysis: 'è¯¥é¢˜è€ƒæŸ¥ç°åœ¨åˆ†è¯ä½œä¸»è¯­ï¼Œrememberingæ˜¯ç°åœ¨åˆ†è¯å½¢å¼' },
      { question: 'She ___ (wear) that dress several times already.', answer: 'has worn', expected: 'è°“è¯­', analysis: 'è¯¥é¢˜è€ƒæŸ¥ç°åœ¨å®Œæˆæ—¶ï¼Œhas wornæ˜¯ç°åœ¨å®Œæˆæ—¶å½¢å¼' },
      { question: 'This is the ___ (funny) story I\'ve heard.', answer: 'funniest', expected: 'å½¢å®¹è¯', analysis: 'è¯¥é¢˜è€ƒæŸ¥å½¢å®¹è¯æœ€é«˜çº§ï¼Œfunniestæ˜¯funnyçš„æœ€é«˜çº§å½¢å¼' },
      { question: 'I don\'t understand ___ she is afraid of dogs.', answer: 'why', expected: 'è¿è¯', analysis: 'è¯¥é¢˜è€ƒæŸ¥è¿è¯whyå¼•å¯¼å®¾è¯­ä»å¥' },
      { question: 'I have ___ apple.', answer: 'an', expected: 'å† è¯', analysis: 'è¯¥é¢˜è€ƒæŸ¥å† è¯ç”¨æ³•' },
      { question: 'She is ___ student.', answer: 'a', expected: 'å† è¯', analysis: 'è¯¥é¢˜è€ƒæŸ¥å† è¯ç”¨æ³•' },
      { question: '___ book is on the table.', answer: 'The', expected: 'å† è¯', analysis: 'è¯¥é¢˜è€ƒæŸ¥å† è¯ç”¨æ³•' },
      { question: 'I saw ___ yesterday.', answer: 'him', expected: 'ä»£è¯', analysis: 'è¯¥é¢˜è€ƒæŸ¥ä»£è¯ç”¨æ³•' },
      { question: 'She runs ___.', answer: 'quickly', expected: 'å‰¯è¯', analysis: 'è¯¥é¢˜è€ƒæŸ¥å‰¯è¯ç”¨æ³•' },
      { question: 'The cat is ___ the table.', answer: 'on', expected: 'ä»‹è¯', analysis: 'è¯¥é¢˜è€ƒæŸ¥ä»‹è¯ç”¨æ³•' },
      // æ–°å¢æµ‹è¯•ç”¨ä¾‹ï¼ˆåŸºäºä½ æä¾›çš„æˆªå›¾ï¼‰
      { question: 'The trees in the park need ____ (take) good care of.', answer: 'to be taken', expected: 'éè°“è¯­', analysis: 'è¯¥é¢˜è€ƒæŸ¥è¢«åŠ¨ä¸å®šå¼ï¼Œneedåæ¥è¢«åŠ¨ä¸å®šå¼to be taken' },
      { question: 'I like to collect different kinds of ____ (toy).', answer: 'toys', expected: 'åè¯', analysis: 'è¯¥é¢˜è€ƒæŸ¥åè¯å¤æ•°ï¼Œtoyçš„å¤æ•°å½¢å¼æ˜¯toys' },
      { question: 'As the sun ____ (set), the sky turned orange and red.', answer: 'set', expected: 'è°“è¯­', analysis: 'è¯¥é¢˜è€ƒæŸ¥è¿‡å»æ—¶æ€ï¼Œsetæ˜¯è¿‡å»æ—¶å½¢å¼' },
      { question: 'They ____ (start) the project two months ago.', answer: 'started', expected: 'è°“è¯­', analysis: 'è¯¥é¢˜è€ƒæŸ¥è¿‡å»æ—¶æ€ï¼Œstartedæ˜¯è¿‡å»æ—¶å½¢å¼' }
    ];
    
    console.log('=== å¼€å§‹æµ‹è¯•åˆ†ç±»ç®—æ³• ===');
    let correctCount = 0;
    let totalCount = testCases.length;
    
    testCases.forEach((testCase, index) => {
      const result = this.getCategoryFromQuestion({
        question: testCase.question,
        answer: testCase.answer,
        analysis: testCase.analysis
      });
      
      const isCorrect = result === testCase.expected;
      if (isCorrect) {
        correctCount++;
      }
      
      console.log(`æµ‹è¯• ${index + 1}: ${isCorrect ? 'âœ…' : 'âŒ'} 
        é¢˜ç›®: ${testCase.question}
        ç­”æ¡ˆ: ${testCase.answer}
        æœŸæœ›: ${testCase.expected}
        å®é™…: ${result}`);
    });
    
    const accuracy = (correctCount / totalCount * 100).toFixed(1);
    console.log(`=== æµ‹è¯•ç»“æœ ===`);
    console.log(`æ­£ç¡®: ${correctCount}/${totalCount}`);
    console.log(`å‡†ç¡®ç‡: ${accuracy}%`);
    
    return {
      correctCount,
      totalCount,
      accuracy: parseFloat(accuracy)
    };
  },

  // æ˜¾ç¤ºå®Œæ•´ç­”æ¡ˆ
  showFullAnswer(e) {
    const dataset = e.currentTarget.dataset;
    const tableId = dataset.tableId;
    console.log('showFullAnswer called with tableId:', tableId);
    
    let answerData = null;
    
    if (tableId && tableId.startsWith('pronoun_')) {
      // ä»£è¯è¡¨æ ¼
      const writingPronouns = require('../../data/writing_pronouns.js');
      const answerKey = tableId === 'pronoun_001' ? 'pronoun_001' : 'pronoun_002';
      answerData = writingPronouns.answers[answerKey];
      
      if (answerData) {
        this.setData({
          showAnswerModal: true,
          currentAnswer: answerData
        });
      } else {
        wx.showToast({
          title: 'ç­”æ¡ˆæ•°æ®åŠ è½½å¤±è´¥',
          icon: 'error',
          duration: 2000
        });
      }
    } else if (tableId && tableId.startsWith('noun_')) {
      // åè¯è¡¨æ ¼
      const writingNouns = require('../../data/writing_nouns.js');
      answerData = writingNouns.answers[tableId];
      
      if (answerData) {
        this.setData({
          showAnswerModal: true,
          currentAnswer: answerData
        });
      } else {
        this.setData({
          showAnswerModal: true,
          currentAnswer: {
            title: 'åè¯å­¦ä¹ æŒ‡å—',
            headers: ['è¦ç‚¹', 'è¯´æ˜'],
            data: [
              ['åç¼€è§„å¾‹', 'ä¸åŒçš„åç¼€æœ‰ä¸åŒçš„è¯æ€§å€¾å‘'],
              ['è®°å¿†æŠ€å·§', 'ç»“åˆå•è¯çš„æ„è¯æ³•æ¥è®°å¿†'],
              ['ç»ƒä¹ å»ºè®®', 'å¤šåšç»ƒä¹ ï¼ŒåŠ æ·±å°è±¡']
            ]
          }
        });
      }
    } else {
      // å…¶ä»–è¡¨æ ¼ç±»å‹çš„é€šç”¨å¤„ç†
      console.log('Processing other table types');
      
      // æ£€æŸ¥æ˜¯å¦æœ‰å½“å‰è¡¨æ ¼æ•°æ®
      const tableIds = Object.keys(this.data.tableData);
      if (tableIds.length > 0) {
        const firstTableId = tableIds[0];
        console.log('Showing answers for:', firstTableId);
        
        let title = 'å­¦ä¹ æŒ‡å—';
        let headers = ['è¦ç‚¹', 'è¯´æ˜'];
        let data = [
          ['å­¦ä¹ æ–¹æ³•', 'ç†è§£è¯­æ³•è§„åˆ™å’Œå˜åŒ–æ¨¡å¼'],
          ['è®°å¿†æŠ€å·§', 'ç»“åˆä¾‹å¥å’Œå®é™…åº”ç”¨'],
          ['ç»ƒä¹ å»ºè®®', 'åå¤ç»ƒä¹ ï¼ŒåŠ æ·±å°è±¡']
        ];
        
        if (firstTableId.includes('present_participle')) {
          title = 'ç°åœ¨åˆ†è¯å­¦ä¹ æŒ‡å—';
          data = [
            ['ä¸€èˆ¬è§„åˆ™', 'åŠ¨è¯åç›´æ¥åŠ -ing'],
            ['å»eè§„åˆ™', 'ä»¥ä¸å‘éŸ³eç»“å°¾çš„åŠ¨è¯ï¼Œå»eåŠ -ing'],
            ['åŒå†™è§„åˆ™', 'é‡è¯»é—­éŸ³èŠ‚ï¼ŒåŒå†™æœ«å°¾è¾…éŸ³å­—æ¯å†åŠ -ing'],
            ['ieå˜y', 'ä»¥ieç»“å°¾çš„åŠ¨è¯ï¼Œå˜ieä¸ºyå†åŠ -ing']
          ];
        } else if (firstTableId.includes('past_participle')) {
          title = 'è¿‡å»åˆ†è¯å­¦ä¹ æŒ‡å—';
          data = [
            ['è§„åˆ™å˜åŒ–', 'ä¸€èˆ¬åŠ¨è¯ç›´æ¥åŠ -ed'],
            ['å»eåŠ d', 'ä»¥eç»“å°¾çš„åŠ¨è¯åªåŠ -d'],
            ['å˜yä¸ºi', 'ä»¥è¾…éŸ³+yç»“å°¾ï¼Œå˜yä¸ºiå†åŠ -ed'],
            ['åŒå†™è§„åˆ™', 'é‡è¯»é—­éŸ³èŠ‚åŒå†™æœ«å°¾è¾…éŸ³å†åŠ -ed'],
            ['ä¸è§„åˆ™', 'ä¸è§„åˆ™åŠ¨è¯éœ€è¦å•ç‹¬è®°å¿†']
          ];
        } else if (firstTableId.includes('comparison')) {
          title = 'æ¯”è¾ƒçº§æœ€é«˜çº§å­¦ä¹ æŒ‡å—';
          data = [
            ['å•éŸ³èŠ‚', 'ç›´æ¥åŠ -er/-est'],
            ['ä»¥eç»“å°¾', 'åªåŠ -r/-st'],
            ['è¾…éŸ³+y', 'å˜yä¸ºiå†åŠ -er/-est'],
            ['é‡è¯»é—­éŸ³èŠ‚', 'åŒå†™æœ«å°¾è¾…éŸ³å†åŠ -er/-est'],
            ['å¤šéŸ³èŠ‚', 'ç”¨more/most']
          ];
        } else if (firstTableId.includes('adverb')) {
          title = 'å‰¯è¯æ„æˆå­¦ä¹ æŒ‡å—';
          data = [
            ['ä¸€èˆ¬è§„åˆ™', 'å½¢å®¹è¯ååŠ -ly'],
            ['ä»¥yç»“å°¾', 'å˜yä¸ºiå†åŠ -ly'],
            ['ä»¥leç»“å°¾', 'å»eåŠ -y'],
            ['åŒå½¢è¯', 'éƒ¨åˆ†å½¢å®¹è¯å‰¯è¯åŒå½¢'],
            ['ç‰¹æ®Šå˜åŒ–', 'éœ€è¦å•ç‹¬è®°å¿†']
          ];
        }
        
        this.setData({
          showAnswerModal: true,
          currentAnswer: {
            title: title,
            headers: headers,
            data: data
          }
        });
      } else {
        wx.showToast({
          title: 'æš‚æ— ç­”æ¡ˆæ•°æ®',
          icon: 'none',
          duration: 2000
        });
      }
    }
  },

  // å…³é—­ç­”æ¡ˆå¼¹çª—
  closeAnswerModal() {
    this.setData({
      showAnswerModal: false
    });
  },

  // é˜»æ­¢äº‹ä»¶å†’æ³¡
  stopPropagation() {
    // ç©ºå‡½æ•°ï¼Œç”¨äºé˜»æ­¢äº‹ä»¶å†’æ³¡
  },

  // noun_003ç‚¹å‡»å¤„ç†
  onNoun003CellTap(e) {
    const { tableId, cellId, word } = e.currentTarget.dataset;
    const tableAnswers = { ...this.data.tableAnswers };
    if (!tableAnswers[tableId]) tableAnswers[tableId] = {};
    tableAnswers[tableId][cellId] = true; // æ ‡è®°å·²ç‚¹

    // åˆ¤æ–­æ˜¯å¦ä¸ºåè¯åç¼€ç»“å°¾
    const nounSuffixes = [
      'ness','th','ment','ion','ure','ance','ence','ity','or','er','ist','ism','al','hood','ship','dom'
    ];
    const lowerWord = (word || '').toLowerCase();
    let isCorrect = false;
    for (let i = 0; i < nounSuffixes.length; i++) {
      if (lowerWord.endsWith(nounSuffixes[i])) {
        isCorrect = true;
        break;
      }
    }
    const showCorrect = { ...this.data.showCorrect };
    if (!showCorrect[tableId]) showCorrect[tableId] = {};
    showCorrect[tableId][cellId] = isCorrect;
    this.setData({
      tableAnswers,
      showCorrect
    });
  },

  // åè¯è¡¨å¤´æç¤ºæŒ‰é’®å¼¹çª—
  showNounHint() {
    wx.showModal({
      title: 'æç¤º',
      content: NOUN_SUFFIX_HINT,
      showCancel: false
    });
  },

  // noun_004è§„åˆ™ç‚¹å‡»åˆ‡æ¢å…¨æ–‡/ç®€ç•¥
  onNoun004RuleTap(e) {
    const row = e.currentTarget.dataset.row;
    const arr = [...this.data.noun004ShowFullRule];
    arr[row] = !arr[row];
    this.setData({ noun004ShowFullRule: arr });
  },

  // noun_004è¾“å…¥å¤„ç†
  onNoun004Input(e) {
    const { tableId, cellId, row, col } = e.currentTarget.dataset;
    const value = e.detail.value;
    const tableAnswers = { ...this.data.tableAnswers };
    if (!tableAnswers[tableId]) tableAnswers[tableId] = {};
    tableAnswers[tableId][cellId] = value;

    // è·å–æ­£ç¡®ç­”æ¡ˆ
    const correct = this.data.correctAnswers[tableId][cellId];
    let status = null;
    if (!value) {
      status = null;
    } else if (this.checkAnswer(value, correct)) {
      status = 'correct';
    } else {
      status = 'wrong';
    }
    const noun004InputStatus = { ...this.data.noun004InputStatus, [`${row*5+col}`]: status };

    this.setData({
      tableAnswers,
      noun004InputStatus
    });
  },

  // ä»£è¯è¡¨æ ¼è¾“å…¥å¤„ç†
  onPronounInput(e) {
    const { table, row, col } = e.currentTarget.dataset;
    const { value } = e.detail;
    
    const key = `${table}_${row}_${col}`;
    
    // æ›´æ–°ç”¨æˆ·è¾“å…¥
    const pronounUserInputs = { ...this.data.pronounUserInputs };
    pronounUserInputs[key] = value;
    
    // è·å–æ­£ç¡®ç­”æ¡ˆ
    const cellIndex = row * 6 + col;
    const correctAnswer = this.data.tableData[table][cellIndex].answer;
    
    // æ£€æŸ¥ç­”æ¡ˆå¹¶æ›´æ–°çŠ¶æ€
    const pronounInputStatus = { ...this.data.pronounInputStatus };
    
    if (value.trim() === '') {
      // ç©ºè¾“å…¥ï¼Œç§»é™¤çŠ¶æ€
      delete pronounInputStatus[key];
    } else if (this.checkAnswer(value, correctAnswer)) {
      // æ­£ç¡®
      pronounInputStatus[key] = 'correct';
    } else {
      // é”™è¯¯
      pronounInputStatus[key] = 'wrong';
    }
    
    this.setData({
      pronounUserInputs,
      pronounInputStatus
    });
  },

  // ç°åœ¨åˆ†è¯è§„åˆ™ç‚¹å‡»åˆ‡æ¢å…¨æ–‡/ç®€ç•¥
  onPresentParticipleRuleTap(e) {
    const row = e.currentTarget.dataset.row;
    const arr = [...this.data.presentParticipleShowFullRule];
    arr[row] = !arr[row];
    this.setData({ presentParticipleShowFullRule: arr });
  },

  // ç°åœ¨åˆ†è¯è¾“å…¥å¤„ç†
  onPresentParticipleInput(e) {
    const { tableId, cellId, row, col } = e.currentTarget.dataset;
    const value = e.detail.value;
    const tableAnswers = { ...this.data.tableAnswers };
    if (!tableAnswers[tableId]) tableAnswers[tableId] = {};
    tableAnswers[tableId][cellId] = value;

    // è·å–æ­£ç¡®ç­”æ¡ˆ
    const correct = this.data.correctAnswers[tableId][cellId];
    let status = null;
    if (!value) {
      status = null;
    } else if (this.checkAnswer(value, correct)) {
      status = 'correct';
    } else {
      status = 'wrong';
    }
    const presentParticipleInputStatus = { ...this.data.presentParticipleInputStatus, [`${row*5+col}`]: status };

    this.setData({
      tableAnswers,
      presentParticipleInputStatus
    });
  },

  // è¿‡å»åˆ†è¯è§„åˆ™ç‚¹å‡»åˆ‡æ¢å…¨æ–‡/ç®€ç•¥
  onPastParticipleRuleTap(e) {
    const row = e.currentTarget.dataset.row;
    const arr = [...this.data.pastParticipleShowFullRule];
    arr[row] = !arr[row];
    this.setData({ pastParticipleShowFullRule: arr });
  },

  // è¿‡å»åˆ†è¯è¾“å…¥å¤„ç†
  onPastParticipleInput(e) {
    const { tableId, cellId, row, col } = e.currentTarget.dataset;
    const value = e.detail.value;
    const tableAnswers = { ...this.data.tableAnswers };
    if (!tableAnswers[tableId]) tableAnswers[tableId] = {};
    tableAnswers[tableId][cellId] = value;

    // è·å–æ­£ç¡®ç­”æ¡ˆ
    const correct = this.data.correctAnswers[tableId][cellId];
    let status = null;
    if (!value) {
      status = null;
    } else if (this.checkAnswer(value, correct)) {
      status = 'correct';
    } else {
      status = 'wrong';
    }
    const pastParticipleInputStatus = { ...this.data.pastParticipleInputStatus, [`${row*5+col}`]: status };

    this.setData({
      tableAnswers,
      pastParticipleInputStatus
    });
  },

  // æ—¶æ€ä¹¦å†™è§„åˆ™ç‚¹å‡»åˆ‡æ¢å…¨æ–‡/ç®€ç•¥
  onTenseWritingRuleTap(e) {
    console.log('ç‚¹å‡»æ—¶æ€ä¹¦å†™è§„åˆ™', e);
    const row = e.currentTarget.dataset.row;
    const arr = [...this.data.tenseWritingShowFullRule];
    arr[row] = !arr[row];
    this.setData({ tenseWritingShowFullRule: arr });
  },

  // è·³è½¬åˆ°æ—¶æ€æ ‡å¿—è¯å¡ç‰‡é¡µé¢
  navigateToTenseSignalCards() {
    wx.navigateTo({
      url: '/pages/tense-signal-cards/index'
    });
  },

  // æ—¶æ€ä¹¦å†™è¾“å…¥å¤„ç†
  onTenseWritingInput(e) {
    console.log('æ—¶æ€ä¹¦å†™è¾“å…¥æ¡†è¾“å…¥', e);
    const { tableId, cellId, row, col } = e.currentTarget.dataset;
    const value = e.detail.value;
    const tableAnswers = { ...this.data.tableAnswers };
    if (!tableAnswers[tableId]) tableAnswers[tableId] = {};
    tableAnswers[tableId][cellId] = value;

    // è·å–æ­£ç¡®ç­”æ¡ˆ
    const cell = this.data.tableData[tableId].find(c => c.cell_id === cellId);
    const correct = cell && cell.correctAnswer;
    let status = null;
    if (!value) {
      status = null;
    } else if (this.checkAnswer(value, correct)) {
      status = 'correct';
    } else {
      status = 'wrong';
    }
    const tenseWritingInputStatus = { ...this.data.tenseWritingInputStatus, [`${row*5+col}`]: status };

    this.setData({
      tableAnswers,
      tenseWritingInputStatus
    });
  },

  // å‰åç¼€è¯†åˆ«è¾“å…¥å¤„ç†
  onPrefixSuffixInput(e) {
    const { tableId, cellId, row } = e.currentTarget.dataset;
    const value = e.detail.value.trim();
    
    // æ›´æ–°ç­”æ¡ˆ
    const tableAnswers = { ...this.data.tableAnswers };
    if (!tableAnswers[tableId]) tableAnswers[tableId] = {};
    tableAnswers[tableId][cellId] = value;

    if (!value) {
      this.setData({
        tableAnswers,
        [`prefixSuffixInputStatus.${row}`]: null
      });
      return;
    }

    // è·å–æ­£ç¡®ç­”æ¡ˆæ•°ç»„
    const tableData = this.data.tableData[tableId];
    const cellData = tableData.find(cell => cell.cell_id === cellId);
    const acceptedAnswers = cellData.acceptedAnswers || [cellData.correctAnswer || cellData.answer];
    
    // æ£€æŸ¥ç­”æ¡ˆæ˜¯å¦æ­£ç¡®
    const isCorrect = acceptedAnswers.some(ans => 
      ans.toLowerCase() === value.toLowerCase()
    );
    
    // æ›´æ–°è¾“å…¥çŠ¶æ€
    this.setData({
      tableAnswers,
      [`prefixSuffixInputStatus.${row}`]: isCorrect ? 'correct' : 'wrong'
    });
  },

  // æ¯”è¾ƒçº§è§„åˆ™ç‚¹å‡»åˆ‡æ¢
  onComparativeRuleTap(e) {
    const { row } = e.currentTarget.dataset;
    const key = `comparativeShowFullRule[${row}]`;
    this.setData({
      [key]: !this.data.comparativeShowFullRule[row]
    });
  },

  // æ¯”è¾ƒçº§è¾“å…¥å¤„ç†
  onComparativeInput(e) {
    const { tableId, cellId, row, col } = e.currentTarget.dataset;
    const value = e.detail.value.trim();
    
    // æ›´æ–°ç­”æ¡ˆ
    const tableAnswers = { ...this.data.tableAnswers };
    if (!tableAnswers[tableId]) tableAnswers[tableId] = {};
    tableAnswers[tableId][cellId] = value;

    if (!value) {
      this.setData({
        tableAnswers,
        [`comparativeInputStatus.${cellId}`]: null
      });
      return;
    }

    // è·å–æ­£ç¡®ç­”æ¡ˆ
    const tableData = this.data.tableData[tableId];
    const cellData = tableData.find(cell => cell.cell_id === cellId);
    const correctAnswer = cellData.correctAnswer || cellData.answer;
    
    // æ£€æŸ¥ç­”æ¡ˆæ˜¯å¦æ­£ç¡®
    const isCorrect = this.checkAnswer(value, correctAnswer);
    
    // æ›´æ–°è¾“å…¥çŠ¶æ€
    this.setData({
      tableAnswers,
      [`comparativeInputStatus.${cellId}`]: isCorrect ? 'correct' : 'wrong'
    });
  },

  // æœ€é«˜çº§è§„åˆ™ç‚¹å‡»åˆ‡æ¢
  onSuperlativeRuleTap(e) {
    const { row } = e.currentTarget.dataset;
    const key = `superlativeShowFullRule[${row}]`;
    this.setData({
      [key]: !this.data.superlativeShowFullRule[row]
    });
  },

  // æœ€é«˜çº§è¾“å…¥å¤„ç†
  onSuperlativeInput(e) {
    const { tableId, cellId, row, col } = e.currentTarget.dataset;
    const value = e.detail.value.trim();
    
    // æ›´æ–°ç­”æ¡ˆ
    const tableAnswers = { ...this.data.tableAnswers };
    if (!tableAnswers[tableId]) tableAnswers[tableId] = {};
    tableAnswers[tableId][cellId] = value;

    if (!value) {
      this.setData({
        tableAnswers,
        [`superlativeInputStatus.${cellId}`]: null
      });
      return;
    }

    // è·å–æ­£ç¡®ç­”æ¡ˆ
    const tableData = this.data.tableData[tableId];
    const cellData = tableData.find(cell => cell.cell_id === cellId);
    const correctAnswer = cellData.correctAnswer || cellData.answer;
    
    // æ£€æŸ¥ç­”æ¡ˆæ˜¯å¦æ­£ç¡®
    const isCorrect = this.checkAnswer(value, correctAnswer);
    
    // æ›´æ–°è¾“å…¥çŠ¶æ€
    this.setData({
      tableAnswers,
      [`superlativeInputStatus.${cellId}`]: isCorrect ? 'correct' : 'wrong'
    });
  },

  // å‰¯è¯è§„åˆ™ç‚¹å‡»åˆ‡æ¢
  onAdverbRuleTap(e) {
    const { row } = e.currentTarget.dataset;
    const key = `adverbShowFullRule[${row}]`;
    this.setData({
      [key]: !this.data.adverbShowFullRule[row]
    });
  },

  // å‰¯è¯è¾“å…¥å¤„ç†
  onAdverbInput(e) {
    const { tableId, cellId, row, col } = e.currentTarget.dataset;
    const value = e.detail.value.trim();
    
    // æ›´æ–°ç­”æ¡ˆ
    const tableAnswers = { ...this.data.tableAnswers };
    if (!tableAnswers[tableId]) tableAnswers[tableId] = {};
    tableAnswers[tableId][cellId] = value;

    if (!value) {
      this.setData({
        tableAnswers,
        [`adverbInputStatus.${cellId}`]: null
      });
      return;
    }

    // è·å–æ­£ç¡®ç­”æ¡ˆ
    const tableData = this.data.tableData[tableId];
    const cellData = tableData.find(cell => cell.cell_id === cellId);
    const correctAnswer = cellData.correctAnswer || cellData.answer;
    
    // æ£€æŸ¥ç­”æ¡ˆæ˜¯å¦æ­£ç¡®
    const isCorrect = this.checkAnswer(value, correctAnswer);
    
    // æ›´æ–°è¾“å…¥çŠ¶æ€
    this.setData({
      tableAnswers,
      [`adverbInputStatus.${cellId}`]: isCorrect ? 'correct' : 'wrong'
    });
  },

  // å¼€å§‹é”™é¢˜å˜å¼è®­ç»ƒ
  startVariantTraining() {
    const wrongQuestions = this.data.wrongQuestions;
    if (wrongQuestions.length === 0) {
      wx.showToast({
        title: 'æ­å–œï¼æ²¡æœ‰é”™é¢˜ï¼Œæ— éœ€å˜å¼è®­ç»ƒ',
        icon: 'success',
        duration: 2000
      });
      return;
    }

    // ç›´æ¥å¼€å§‹ç”Ÿæˆå˜å¼é¢˜ç›®ï¼Œæ— éœ€äºŒæ¬¡ç¡®è®¤
    wx.showLoading({
      title: 'ç”Ÿæˆå˜å¼é¢˜ç›®ä¸­...'
    });

    // è°ƒç”¨é”™é¢˜å˜å¼è®­ç»ƒé€»è¾‘
    this.generateVariantQuestionsFromWrongQuestions(wrongQuestions);
  },

  // æ ¹æ®é”™é¢˜ç”Ÿæˆå˜å¼é¢˜ç›®
  generateVariantQuestionsFromWrongQuestions(wrongQuestions) {
    try {
      // åŠ è½½é¢˜åº“æ•°æ®
      const questionsData = require('../../data/intermediate_questions.js');
      
      // åˆ†æé”™é¢˜çš„åˆ†ç±»åˆ†å¸ƒ
      const categoryCount = {};
      const categoryErrorCount = {};
      
      // åˆ†ç±»æ˜ å°„è¡¨ï¼ˆä¸é¦–é¡µä¿æŒä¸€è‡´ï¼‰
      const categoryMapping = {
        // ä»‹è¯ç›¸å…³åˆ†ç±»
        "ä»‹è¯ï¼ˆ1ï¼‰": "ä»‹è¯", "ä»‹è¯ï¼ˆ2ï¼‰": "ä»‹è¯", "ä»‹è¯ï¼ˆ3ï¼‰": "ä»‹è¯",
        // ä»£è¯ç›¸å…³åˆ†ç±»
        "ä»£è¯ï¼ˆ1ï¼‰": "ä»£è¯", "ä»£è¯ï¼ˆ2ï¼‰": "ä»£è¯", "ä»£è¯ï¼ˆ3ï¼‰": "ä»£è¯", 
        "ä»£è¯ï¼ˆ4ï¼‰": "ä»£è¯", "ä»£è¯ï¼ˆ5ï¼‰": "ä»£è¯", "ä»£è¯ï¼ˆ6ï¼‰": "ä»£è¯",
        // è¿è¯ç›¸å…³åˆ†ç±»
        "è¿è¯ï¼ˆ1ï¼‰": "è¿è¯", "è¿è¯ï¼ˆ2ï¼‰": "è¿è¯", "è¿è¯ï¼ˆ3ï¼‰": "è¿è¯",
        "è¿è¯ï¼ˆ4ï¼‰": "è¿è¯", "è¿è¯ï¼ˆ5ï¼‰": "è¿è¯", "è¿è¯ï¼ˆ6ï¼‰": "è¿è¯",
        // å† è¯ç›¸å…³åˆ†ç±»
        "å† è¯ï¼ˆ1ï¼‰": "å† è¯", "å† è¯ï¼ˆ2ï¼‰": "å† è¯", "å† è¯ï¼ˆ3ï¼‰": "å† è¯", "å† è¯ï¼ˆ4ï¼‰": "å† è¯",
        // åè¯ç›¸å…³åˆ†ç±»
        "åè¯ï¼ˆ1ï¼‰": "åè¯", "åè¯ï¼ˆ2ï¼‰": "åè¯", "åè¯ï¼ˆ3ï¼‰": "åè¯", 
        "åè¯ï¼ˆ4ï¼‰": "åè¯", "åè¯ï¼ˆ5ï¼‰": "åè¯",
        // åŠ¨è¯ç›¸å…³åˆ†ç±»
        "åŠ¨è¯ï¼ˆ1ï¼‰": "åŠ¨è¯", "åŠ¨è¯ï¼ˆ2ï¼‰": "åŠ¨è¯", "åŠ¨è¯ï¼ˆ3ï¼‰": "åŠ¨è¯", 
        "åŠ¨è¯ï¼ˆ4ï¼‰": "åŠ¨è¯", "åŠ¨è¯ï¼ˆ5ï¼‰": "åŠ¨è¯",
        // è°“è¯­ç›¸å…³åˆ†ç±»
        "è°“è¯­ï¼ˆ1ï¼‰": "è°“è¯­", "è°“è¯­ï¼ˆ2ï¼‰": "è°“è¯­", "è°“è¯­ï¼ˆ3ï¼‰": "è°“è¯­", 
        "è°“è¯­ï¼ˆ4ï¼‰": "è°“è¯­", "è°“è¯­ï¼ˆ5ï¼‰": "è°“è¯­", "è°“è¯­ï¼ˆ6ï¼‰": "è°“è¯­", "è°“è¯­ï¼ˆ7ï¼‰": "è°“è¯­",
        "è°“è¯­ï¼ˆ8ï¼‰": "è°“è¯­", "è°“è¯­ï¼ˆ9ï¼‰": "è°“è¯­",
        // éè°“è¯­ç›¸å…³åˆ†ç±»
        "éè°“è¯­ï¼ˆ1ï¼‰": "éè°“è¯­", "éè°“è¯­ï¼ˆ2ï¼‰": "éè°“è¯­", "éè°“è¯­ï¼ˆ3ï¼‰": "éè°“è¯­", "éè°“è¯­ï¼ˆ4ï¼‰": "éè°“è¯­",
        // å½¢å®¹è¯ç›¸å…³åˆ†ç±»
        "å½¢å®¹è¯ï¼ˆ1ï¼‰": "å½¢å®¹è¯", "å½¢å®¹è¯ï¼ˆ2ï¼‰": "å½¢å®¹è¯", "å½¢å®¹è¯ï¼ˆ3ï¼‰": "å½¢å®¹è¯",
        // å‰¯è¯ç›¸å…³åˆ†ç±»
        "å‰¯è¯ï¼ˆ1ï¼‰": "å‰¯è¯", "å‰¯è¯ï¼ˆ2ï¼‰": "å‰¯è¯", "å‰¯è¯ï¼ˆ3ï¼‰": "å‰¯è¯", "å‰¯è¯ï¼ˆ4ï¼‰": "å‰¯è¯",
        // å®šè¯­ä»å¥ç›¸å…³åˆ†ç±»
        "å®šè¯­ä»å¥ï¼ˆ1ï¼‰": "å®šè¯­ä»å¥", "å®šè¯­ä»å¥ï¼ˆ2ï¼‰": "å®šè¯­ä»å¥", "å®šè¯­ä»å¥ï¼ˆ3ï¼‰": "å®šè¯­ä»å¥",
        "å®šè¯­ä»å¥ï¼ˆ4ï¼‰": "å®šè¯­ä»å¥", "å®šè¯­ä»å¥ï¼ˆ5ï¼‰": "å®šè¯­ä»å¥",
        // çŠ¶è¯­ä»å¥ç›¸å…³åˆ†ç±»
        "çŠ¶è¯­å’Œä»å¥ï¼ˆ1ï¼‰": "çŠ¶è¯­ä»å¥", "çŠ¶è¯­å’Œä»å¥ï¼ˆ2ï¼‰": "çŠ¶è¯­ä»å¥", "çŠ¶è¯­å’Œä»å¥ï¼ˆ3ï¼‰": "çŠ¶è¯­ä»å¥",
        "çŠ¶è¯­å’Œä»å¥ï¼ˆ4ï¼‰": "çŠ¶è¯­ä»å¥", "çŠ¶è¯­å’Œä»å¥ï¼ˆ5ï¼‰": "çŠ¶è¯­ä»å¥"
      };
      
      // é¢˜åº“åˆ†ç±»æ˜ å°„è¡¨ï¼ˆåŒ…å«å…·ä½“è¯­æ³•ç‚¹æ˜ å°„ï¼‰
      const questionBankMapping = {
        // å…·ä½“è¯­æ³•ç‚¹ç›´æ¥æ˜ å°„
        'ä»£è¯ï¼ˆ1ï¼‰': ['ä»£è¯ï¼ˆ1ï¼‰'],
        'ä»£è¯ï¼ˆ2ï¼‰': ['ä»£è¯ï¼ˆ2ï¼‰'],
        'ä»£è¯ï¼ˆ3ï¼‰': ['ä»£è¯ï¼ˆ3ï¼‰'],
        'ä»£è¯ï¼ˆ4ï¼‰': ['ä»£è¯ï¼ˆ4ï¼‰'],
        'ä»£è¯ï¼ˆ5ï¼‰': ['ä»£è¯ï¼ˆ5ï¼‰'],
        'ä»£è¯ï¼ˆ6ï¼‰': ['ä»£è¯ï¼ˆ6ï¼‰'],
        'åŠ¨è¯ï¼ˆ1ï¼‰': ['åŠ¨è¯ï¼ˆ1ï¼‰'],
        'åŠ¨è¯ï¼ˆ2ï¼‰': ['åŠ¨è¯ï¼ˆ2ï¼‰'],
        'åŠ¨è¯ï¼ˆ3ï¼‰': ['åŠ¨è¯ï¼ˆ3ï¼‰'],
        'åŠ¨è¯ï¼ˆ4ï¼‰': ['åŠ¨è¯ï¼ˆ4ï¼‰'],
        'åŠ¨è¯ï¼ˆ5ï¼‰': ['åŠ¨è¯ï¼ˆ5ï¼‰'],
        'ä»‹è¯ï¼ˆ1ï¼‰': ['ä»‹è¯ï¼ˆ1ï¼‰'],
        'ä»‹è¯ï¼ˆ2ï¼‰': ['ä»‹è¯ï¼ˆ2ï¼‰'],
        'ä»‹è¯ï¼ˆ3ï¼‰': ['ä»‹è¯ï¼ˆ3ï¼‰'],
        'è¿è¯ï¼ˆ1ï¼‰': ['è¿è¯ï¼ˆ1ï¼‰'],
        'è¿è¯ï¼ˆ2ï¼‰': ['è¿è¯ï¼ˆ2ï¼‰'],
        'è¿è¯ï¼ˆ3ï¼‰': ['è¿è¯ï¼ˆ3ï¼‰'],
        'è¿è¯ï¼ˆ4ï¼‰': ['è¿è¯ï¼ˆ4ï¼‰'],
        'è¿è¯ï¼ˆ5ï¼‰': ['è¿è¯ï¼ˆ5ï¼‰'],
        'è¿è¯ï¼ˆ6ï¼‰': ['è¿è¯ï¼ˆ6ï¼‰'],
        'å† è¯ï¼ˆ1ï¼‰': ['å† è¯ï¼ˆ1ï¼‰'],
        'å† è¯ï¼ˆ2ï¼‰': ['å† è¯ï¼ˆ2ï¼‰'],
        'å† è¯ï¼ˆ3ï¼‰': ['å† è¯ï¼ˆ3ï¼‰'],
        'å† è¯ï¼ˆ4ï¼‰': ['å† è¯ï¼ˆ4ï¼‰'],
        'åè¯ï¼ˆ1ï¼‰': ['åè¯ï¼ˆ1ï¼‰'],
        'åè¯ï¼ˆ2ï¼‰': ['åè¯ï¼ˆ2ï¼‰'],
        'åè¯ï¼ˆ3ï¼‰': ['åè¯ï¼ˆ3ï¼‰'],
        'åè¯ï¼ˆ4ï¼‰': ['åè¯ï¼ˆ4ï¼‰'],
        'åè¯ï¼ˆ5ï¼‰': ['åè¯ï¼ˆ5ï¼‰'],
        'åè¯ï¼ˆ6ï¼‰': ['åè¯ï¼ˆ6ï¼‰'],
        'è°“è¯­ï¼ˆ1ï¼‰': ['è°“è¯­ï¼ˆ1ï¼‰'],
        'è°“è¯­ï¼ˆ2ï¼‰': ['è°“è¯­ï¼ˆ2ï¼‰'],
        'è°“è¯­ï¼ˆ3ï¼‰': ['è°“è¯­ï¼ˆ3ï¼‰'],
        'è°“è¯­ï¼ˆ4ï¼‰': ['è°“è¯­ï¼ˆ4ï¼‰'],
        'è°“è¯­ï¼ˆ5ï¼‰': ['è°“è¯­ï¼ˆ5ï¼‰'],
        'è°“è¯­ï¼ˆ6ï¼‰': ['è°“è¯­ï¼ˆ6ï¼‰'],
        'è°“è¯­ï¼ˆ7ï¼‰': ['è°“è¯­ï¼ˆ7ï¼‰'],
        'è°“è¯­ï¼ˆ8ï¼‰': ['è°“è¯­ï¼ˆ8ï¼‰'],
        'è°“è¯­ï¼ˆ9ï¼‰': ['è°“è¯­ï¼ˆ9ï¼‰'],
        'éè°“è¯­ï¼ˆ1ï¼‰': ['éè°“è¯­ï¼ˆ1ï¼‰'],
        'éè°“è¯­ï¼ˆ2ï¼‰': ['éè°“è¯­ï¼ˆ2ï¼‰'],
        'éè°“è¯­ï¼ˆ3ï¼‰': ['éè°“è¯­ï¼ˆ3ï¼‰'],
        'éè°“è¯­ï¼ˆ4ï¼‰': ['éè°“è¯­ï¼ˆ4ï¼‰'],
        'å½¢å®¹è¯ï¼ˆ1ï¼‰': ['å½¢å®¹è¯ï¼ˆ1ï¼‰'],
        'å½¢å®¹è¯ï¼ˆ2ï¼‰': ['å½¢å®¹è¯ï¼ˆ2ï¼‰'],
        'å½¢å®¹è¯ï¼ˆ3ï¼‰': ['å½¢å®¹è¯ï¼ˆ3ï¼‰'],
        'å‰¯è¯ï¼ˆ1ï¼‰': ['å‰¯è¯ï¼ˆ1ï¼‰'],
        'å‰¯è¯ï¼ˆ2ï¼‰': ['å‰¯è¯ï¼ˆ2ï¼‰'],
        'å‰¯è¯ï¼ˆ3ï¼‰': ['å‰¯è¯ï¼ˆ3ï¼‰'],
        'å‰¯è¯ï¼ˆ4ï¼‰': ['å‰¯è¯ï¼ˆ4ï¼‰'],
        'å®šè¯­ä»å¥ï¼ˆ1ï¼‰': ['å®šè¯­ä»å¥ï¼ˆ1ï¼‰'],
        'å®šè¯­ä»å¥ï¼ˆ2ï¼‰': ['å®šè¯­ä»å¥ï¼ˆ2ï¼‰'],
        'å®šè¯­ä»å¥ï¼ˆ3ï¼‰': ['å®šè¯­ä»å¥ï¼ˆ3ï¼‰'],
        'å®šè¯­ä»å¥ï¼ˆ4ï¼‰': ['å®šè¯­ä»å¥ï¼ˆ4ï¼‰'],
        'å®šè¯­ä»å¥ï¼ˆ5ï¼‰': ['å®šè¯­ä»å¥ï¼ˆ5ï¼‰'],
        'çŠ¶è¯­å’Œä»å¥ï¼ˆ1ï¼‰': ['çŠ¶è¯­å’Œä»å¥ï¼ˆ1ï¼‰'],
        'çŠ¶è¯­å’Œä»å¥ï¼ˆ2ï¼‰': ['çŠ¶è¯­å’Œä»å¥ï¼ˆ2ï¼‰'],
        'çŠ¶è¯­å’Œä»å¥ï¼ˆ3ï¼‰': ['çŠ¶è¯­å’Œä»å¥ï¼ˆ3ï¼‰'],
        'çŠ¶è¯­å’Œä»å¥ï¼ˆ4ï¼‰': ['çŠ¶è¯­å’Œä»å¥ï¼ˆ4ï¼‰'],
        'çŠ¶è¯­å’Œä»å¥ï¼ˆ5ï¼‰': ['çŠ¶è¯­å’Œä»å¥ï¼ˆ5ï¼‰'],
        // å¤§ç±»æ˜ å°„ï¼ˆå…œåº•ï¼‰
        'ä»‹è¯': ['ä»‹è¯ç»¼åˆ', 'å›ºå®šæ­é…', 'ä»‹è¯ + åè¯/åŠ¨åè¯'],
        'ä»£è¯': ['ä»£è¯ç»¼åˆ', 'äººç§°ä»£è¯', 'ç‰©ä¸»ä»£è¯', 'åèº«ä»£è¯', 'å…³ç³»ä»£è¯', 'itç›¸å…³'],
        'è¿è¯': ['å¹¶åˆ—è¿è¯ç»¼åˆ', 'ä»å±è¿è¯ç»¼åˆ', 'è¿è¯ä¸å/åŠ¨/å½¢/å‰¯ç»¼åˆ', 'è¿è¯ä¸åè¯', 'è¿è¯ä¸åŠ¨è¯', 'è¿è¯ä¸å½¢å®¹è¯'],
        'å† è¯': ['å† è¯ç»¼åˆ', 'æ³›æŒ‡ä¸ç‰¹æŒ‡', 'aå’Œan', 'theçš„ç‰¹æ®Šç”¨æ³•'],
        'åè¯': ['åè¯ç»¼åˆ', 'åè¯å¤æ•°ä¹¦å†™ç»¼åˆ', 'ä»¥oç»“å°¾', 'ä»¥yç»“å°¾', 's/sh/ch/xç»“å°¾', 'f/feç»“å°¾'],
        'åŠ¨è¯': ['åŠ¨è¯ç»¼åˆ', 'è°“è¯­ç»¼åˆ', 'éè°“è¯­ç»¼åˆ', 'è¢«åŠ¨å†™beå—', 'å¹¶åˆ—å¥ä¸åŠ¨è¯', 'ä¸»ä»å¥ä¸åŠ¨è¯', 'æ’å…¥è¯­ä¸åŠ¨è¯'],
        'è°“è¯­': ['æ—¶æ€ç»¼åˆ', 'ç°åœ¨æ—¶', 'è¿‡å»æ—¶', 'å®Œæˆæ—¶', 'è¿›è¡Œæ—¶', 'è¢«åŠ¨è¯­æ€'],
        'éè°“è¯­': ['ç°åœ¨åˆ†è¯ç»¼åˆ', 'è¿‡å»åˆ†è¯ç»¼åˆ', 'ä¸å®šå¼ç»¼åˆ'],
        'å½¢å®¹è¯': ['å½¢å®¹è¯ç»¼åˆ', 'æ¯”è¾ƒçº§', 'æœ€é«˜çº§'],
        'å‰¯è¯': ['å‰¯è¯ç»¼åˆ', 'å‰¯è¯ä¿®é¥°åŠ¨è¯', 'å‰¯è¯ä¿®é¥°å¥å­', 'å‰¯è¯ä¿®é¥°å½¢å®¹è¯/å‰¯è¯'],
        'å®šè¯­ä»å¥': ['å®šè¯­ä»å¥ç»¼åˆ', 'thatèƒ½å¡«å—', 'whoå’Œwhiché€‰å“ªä¸ª', 'whose', 'whichå’Œwhen/whereæ··æ·†'],
        'çŠ¶è¯­ä»å¥': ['çŠ¶è¯­ä»å¥ç»¼åˆ', 'when', 'where', 'how', 'why']
      };
      
      // ç»Ÿè®¡é”™é¢˜åˆ†ç±»
      wrongQuestions.forEach(question => {
        // ä¼˜å…ˆä½¿ç”¨åŸå§‹åˆ†ç±»ä¿¡æ¯ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨æ˜ å°„åçš„åˆ†ç±»
        const originalCategory = question.category || question.grammarPoint || 'ç»¼åˆç»ƒä¹ ';
        console.log(`é”™é¢˜åŸå§‹åˆ†ç±»: ${originalCategory}, é¢˜ç›®: ${question.question}`);
        
        // å¦‚æœåŸå§‹åˆ†ç±»æ˜¯å…·ä½“çš„è¯­æ³•ç‚¹ï¼ˆå¦‚"ä»£è¯ï¼ˆ1ï¼‰"ï¼‰ï¼Œç›´æ¥ä½¿ç”¨
        if (originalCategory && originalCategory !== 'ç»¼åˆç»ƒä¹ ' && originalCategory !== 'ç»¼åˆ') {
          categoryCount[originalCategory] = (categoryCount[originalCategory] || 0) + 1;
          categoryErrorCount[originalCategory] = (categoryErrorCount[originalCategory] || 0) + (question.errorCount || 1);
        } else {
          // å¦‚æœåŸå§‹åˆ†ç±»ä¸æ˜ç¡®ï¼Œä½¿ç”¨æ˜ å°„åçš„åˆ†ç±»
          const mappedCategory = categoryMapping[originalCategory] || originalCategory;
          categoryCount[mappedCategory] = (categoryCount[mappedCategory] || 0) + 1;
          categoryErrorCount[mappedCategory] = (categoryErrorCount[mappedCategory] || 0) + (question.errorCount || 1);
        }
      });

      // æŒ‰é”™è¯¯é¢‘æ¬¡æ’åºï¼Œå–å‰3ç±»é«˜é¢‘è€ƒç‚¹ï¼ˆæ’é™¤"ç»¼åˆ"åˆ†ç±»ï¼‰
      const sortedCategories = Object.keys(categoryErrorCount)
        .filter(category => category !== 'ç»¼åˆ' && category !== 'ç»¼åˆç»ƒä¹ ' && category !== 'å…¶ä»–')
        .sort((a, b) => categoryErrorCount[b] - categoryErrorCount[a])
        .slice(0, Math.min(3, Object.keys(categoryErrorCount).length));

      console.log('é”™é¢˜åˆ†ç±»åˆ†æ:', {
        totalWrongQuestions: wrongQuestions.length,
        categoryCount: categoryCount,
        categoryErrorCount: categoryErrorCount,
        topCategories: sortedCategories
      });

      // ç”Ÿæˆå˜å¼é¢˜ç›®
      const variantQuestions = [];
      const wrongQuestionTexts = wrongQuestions.map(q => q.question || q.text);
      
      // ä¸ºæ¯ä¸ªé«˜é¢‘åˆ†ç±»ç”Ÿæˆå˜å¼é¢˜ç›®
      sortedCategories.forEach(category => {
        const errorCount = categoryErrorCount[category];
        const questionsToGenerate = Math.min(3, Math.max(2, Math.ceil(errorCount / 2)));
        
        console.log(`å¤„ç†åˆ†ç±»: ${category}, é”™è¯¯æ¬¡æ•°: ${errorCount}, è®¡åˆ’ç”Ÿæˆ: ${questionsToGenerate} é“é¢˜`);
        
        // è·å–è¯¥åˆ†ç±»å¯¹åº”çš„é¢˜åº“é”®å
        const mappedCategories = questionBankMapping[category] || [category];
        console.log(`åˆ†ç±» ${category} æ˜ å°„åˆ°é¢˜åº“åˆ†ç±»: ${mappedCategories.join(', ')}`);
        
        let availableQuestions = [];
        
        // ä»æ˜ å°„çš„åˆ†ç±»ä¸­æ”¶é›†é¢˜ç›®
        mappedCategories.forEach(cat => {
          if (questionsData[cat] && questionsData[cat].length > 0) {
            console.log(`ä»åˆ†ç±» ${cat} æ‰¾åˆ° ${questionsData[cat].length} é“é¢˜`);
            availableQuestions = availableQuestions.concat(questionsData[cat]);
          } else {
            console.log(`åˆ†ç±» ${cat} æ²¡æœ‰æ‰¾åˆ°é¢˜ç›®`);
          }
        });
        
        // å¦‚æœç›´æ¥åˆ†ç±»æ²¡æœ‰æ‰¾åˆ°é¢˜ç›®ï¼Œä»æ‰€æœ‰é¢˜ç›®ä¸­ç­›é€‰å‡ºå¯¹åº”categoryçš„é¢˜ç›®
        if (availableQuestions.length === 0) {
          console.log(`å°è¯•ä»æ‰€æœ‰é¢˜ç›®ä¸­ç­›é€‰categoryä¸º ${category} çš„é¢˜ç›®`);
          Object.keys(questionsData).forEach(bigCategory => {
            const bigCategoryQuestions = questionsData[bigCategory] || [];
            const filteredQuestions = bigCategoryQuestions.filter(q => 
              q.category === category
            );
            if (filteredQuestions.length > 0) {
              console.log(`ä»å¤§ç±» ${bigCategory} ä¸­ç­›é€‰å‡º ${filteredQuestions.length} é“categoryä¸º ${category} çš„é¢˜ç›®`);
              availableQuestions = availableQuestions.concat(filteredQuestions);
            }
          });
        }
        
        if (availableQuestions.length > 0) {
          // è¿‡æ»¤æ‰ä¸é”™é¢˜é‡å¤çš„é¢˜ç›®
          const filteredQuestions = availableQuestions.filter(q => 
            !wrongQuestionTexts.includes(q.text || q.question)
          );
          
          console.log(`è¿‡æ»¤é‡å¤é¢˜ç›®åå‰©ä½™: ${filteredQuestions.length} é“é¢˜`);
          
          // å¦‚æœè¿‡æ»¤åé¢˜ç›®ä¸å¤Ÿï¼Œä½¿ç”¨åŸé¢˜ç›®
          const questionsToUse = filteredQuestions.length >= questionsToGenerate ? 
            filteredQuestions : availableQuestions;
          
          // éšæœºé€‰æ‹©é¢˜ç›®
          const shuffled = [...questionsToUse].sort(() => 0.5 - Math.random());
          const selectedQuestions = shuffled.slice(0, questionsToGenerate);
          
          // æ ‡å‡†åŒ–é¢˜ç›®æ ¼å¼
          const normalizedSelected = selectedQuestions.map(q => ({
            text: q.text || q.question,
            answer: q.answer,
            analysis: q.analysis || q.explanation || '',
            category: q.category || category
          }));
          
          variantQuestions.push(...normalizedSelected);
          
          console.log(`ä¸ºåˆ†ç±» ${category} ç”Ÿæˆäº† ${selectedQuestions.length} é“å˜å¼é¢˜`);
        } else {
          console.warn(`åˆ†ç±» ${category} æ²¡æœ‰æ‰¾åˆ°å¯ç”¨é¢˜ç›®ï¼Œæ˜ å°„çš„åˆ†ç±»: ${mappedCategories.join(', ')}`);
        }
      });

      // æ ¹æ®é”™é¢˜åˆ†ç±»å’Œæ•°é‡ç”Ÿæˆå¯¹åº”çš„å˜å¼é¢˜ç›®
      console.log('å¼€å§‹æ ¹æ®é”™é¢˜åˆ†ç±»å’Œæ•°é‡ç”Ÿæˆå˜å¼é¢˜ç›®...');
      
      // ç»Ÿè®¡æ¯ä¸ªå…·ä½“åˆ†ç±»çš„é”™é¢˜æ•°é‡
      const categoryWrongCount = {};
      wrongQuestions.forEach(question => {
        const originalCategory = question.category || question.grammarPoint || 'ç»¼åˆç»ƒä¹ ';
        categoryWrongCount[originalCategory] = (categoryWrongCount[originalCategory] || 0) + 1;
      });
      
      console.log('é”™é¢˜åˆ†ç±»ç»Ÿè®¡:', categoryWrongCount);
      
      // ä¸ºæ¯ä¸ªé”™é¢˜åˆ†ç±»ç”Ÿæˆå¯¹åº”æ•°é‡çš„å˜å¼é¢˜ç›®
      const finalVariantQuestions = [];
      Object.keys(categoryWrongCount).forEach(category => {
        const wrongCount = categoryWrongCount[category];
        console.log(`ä¸ºåˆ†ç±» ${category} ç”Ÿæˆ ${wrongCount} é“å˜å¼é¢˜ï¼ˆå¯¹åº”é”™é¢˜æ•°é‡ï¼‰`);
        
        // ä»å·²ç”Ÿæˆçš„å˜å¼é¢˜ç›®ä¸­ç­›é€‰å‡ºè¯¥åˆ†ç±»çš„é¢˜ç›®
        const categoryQuestions = variantQuestions.filter(q => 
          q.category === category || q.category === categoryMapping[category]
        );
        
        // å¦‚æœè¯¥åˆ†ç±»çš„é¢˜ç›®ä¸å¤Ÿï¼Œä»é¢˜åº“ä¸­è¡¥å……
        if (categoryQuestions.length < wrongCount) {
          console.log(`åˆ†ç±» ${category} çš„å˜å¼é¢˜ç›®ä¸è¶³ï¼Œéœ€è¦è¡¥å…… ${wrongCount - categoryQuestions.length} é“é¢˜`);
          
          // è·å–è¯¥åˆ†ç±»å¯¹åº”çš„é¢˜åº“é”®å
          const mappedCategories = questionBankMapping[category] || [category];
          let availableQuestions = [];
          
          // ä»æ˜ å°„çš„åˆ†ç±»ä¸­æ”¶é›†é¢˜ç›®
          mappedCategories.forEach(cat => {
            if (questionsData[cat] && questionsData[cat].length > 0) {
              availableQuestions = availableQuestions.concat(questionsData[cat]);
            }
          });
          
          // å¦‚æœç›´æ¥åˆ†ç±»æ²¡æœ‰æ‰¾åˆ°é¢˜ç›®ï¼Œä»æ‰€æœ‰é¢˜ç›®ä¸­ç­›é€‰å‡ºå¯¹åº”categoryçš„é¢˜ç›®
          if (availableQuestions.length === 0) {
            Object.keys(questionsData).forEach(bigCategory => {
              const bigCategoryQuestions = questionsData[bigCategory] || [];
              const filteredQuestions = bigCategoryQuestions.filter(q => 
                q.category === category
              );
              if (filteredQuestions.length > 0) {
                availableQuestions = availableQuestions.concat(filteredQuestions);
              }
            });
          }
          
          // è¿‡æ»¤æ‰ä¸é”™é¢˜é‡å¤çš„é¢˜ç›®
          const filteredQuestions = availableQuestions.filter(q => 
            !wrongQuestionTexts.includes(q.text || q.question)
          );
          
          // éšæœºé€‰æ‹©è¡¥å……é¢˜ç›®
          const shuffled = [...filteredQuestions].sort(() => 0.5 - Math.random());
          const supplementaryQuestions = shuffled.slice(0, wrongCount - categoryQuestions.length);
          
          // æ ‡å‡†åŒ–é¢˜ç›®æ ¼å¼
          const normalizedSupplementary = supplementaryQuestions.map(q => ({
            text: q.text || q.question,
            answer: q.answer,
            analysis: q.analysis || q.explanation || '',
            category: q.category || category
          }));
          
          categoryQuestions.push(...normalizedSupplementary);
        }
        
        // é€‰æ‹©æŒ‡å®šæ•°é‡çš„é¢˜ç›®ï¼ˆä¸è¶…è¿‡é”™é¢˜æ•°é‡ï¼‰
        const selectedQuestions = categoryQuestions.slice(0, wrongCount);
        finalVariantQuestions.push(...selectedQuestions);
        
        console.log(`åˆ†ç±» ${category} æœ€ç»ˆç”Ÿæˆ ${selectedQuestions.length} é“å˜å¼é¢˜`);
      });
      
      // ä½¿ç”¨æœ€ç»ˆç”Ÿæˆçš„å˜å¼é¢˜ç›®
      variantQuestions.splice(0, variantQuestions.length, ...finalVariantQuestions);

      wx.hideLoading();
      
      console.log('å˜å¼ç»ƒä¹ ç”Ÿæˆç»“æœ:', {
        totalGenerated: variantQuestions.length,
        sortedCategories: sortedCategories
      });

      if (variantQuestions.length === 0) {
            wx.showToast({
          title: 'æ— æ³•ç”Ÿæˆå˜å¼ç»ƒä¹ ',
              icon: 'none'
            });
        return;
      }

      // ç›´æ¥å¼€å§‹å˜å¼ç»ƒä¹ ï¼Œæ— éœ€äºŒæ¬¡ç¡®è®¤
      this.startVariantExercise(variantQuestions);
      
    } catch (error) {
      console.error('ç”Ÿæˆé”™é¢˜å˜å¼ç»ƒä¹ å¤±è´¥:', error);
      wx.hideLoading();
      wx.showToast({
        title: 'ç”Ÿæˆç»ƒä¹ å¤±è´¥',
        icon: 'none'
      });
    }
  },

  // å¼€å§‹å˜å¼ç»ƒä¹ 
  startVariantExercise(variantQuestions) {
    // é‡ç½®çŠ¶æ€ï¼Œå¼€å§‹æ–°çš„ç»ƒä¹ 
    this.setData({
      questions: variantQuestions,
      answers: new Array(variantQuestions.length).fill(''),
      results: [],
      correctionCompleted: false,
      submitting: false,
      mode: 'variant',
      isWrongQuestionVariant: true
    });
    
    wx.showToast({
      title: `å¼€å§‹å˜å¼è®­ç»ƒï¼Œå…±${variantQuestions.length}é“é¢˜`,
      icon: 'success',
      duration: 2000
    });
  },

  // å¼€å§‹ä¹¦å†™è§„èŒƒè®­ç»ƒ
  startStandardTraining() {
    // å¼€å§‹æ ‡å‡†è®­ç»ƒ
    console.log('å¼€å§‹æ ‡å‡†è®­ç»ƒ');
    
    // è·³è½¬åˆ°ç»ƒä¹ é¡µé¢ï¼Œä½¿ç”¨æ ‡å‡†æ¨¡å¼
    const url = `/pages/exercise-page/index?questions=${encodeURIComponent(JSON.stringify(this.data.questions))}&level=${this.data.level}&mode=standard&title=${encodeURIComponent('æ ‡å‡†è®­ç»ƒ')}`;
    
    wx.navigateTo({
      url: url,
      success: () => {
        console.log('è·³è½¬åˆ°æ ‡å‡†è®­ç»ƒé¡µé¢æˆåŠŸ');
      },
      fail: (error) => {
        console.error('è·³è½¬åˆ°æ ‡å‡†è®­ç»ƒé¡µé¢å¤±è´¥:', error);
        wx.showToast({
          title: 'è·³è½¬å¤±è´¥',
          icon: 'none'
        });
      }
    });
  },

  // æ–°å¢ï¼šçŸ¥è¯†ç‚¹åŒå‘è”åŠ¨æ¨¡å—ç›¸å…³æ–¹æ³•

  // å¤„ç†é”™é¢˜ç»Ÿè®¡å’Œè§¦å‘ä¸“é¡¹ç»ƒä¹ 
  handleWrongQuestion(question, index) {
    // è·å–é¢˜ç›®ç±»å‹ï¼ˆè¯­æ³•ç‚¹åˆ†ç±»ï¼‰
    const grammarType = this.getQuestionType(question);
    
    if (grammarType) {
      // ç´¯åŠ é”™è¯¯æ¬¡æ•°
      const currentCount = this.data.errorCounts[grammarType] || 0;
      const newCount = currentCount + 1;
      
      const newErrorCounts = { ...this.data.errorCounts };
      newErrorCounts[grammarType] = newCount;
      
      this.setData({
        errorCounts: newErrorCounts,
        currentQuestionIndex: index,
        currentQuestionType: grammarType
      });
      
      console.log(`[é”™é¢˜ç»Ÿè®¡] ${grammarType} é”™è¯¯æ¬¡æ•°: ${newCount}`);
      
      // æ£€æŸ¥æ˜¯å¦è§¦å‘ä¸“é¡¹ç»ƒä¹ ï¼ˆé”™è¯¯3æ¬¡æˆ–ä»¥ä¸Šï¼‰
      if (newCount >= 3) {
        this.confirmSpecialPractice(grammarType);
      }
    }
  },

  // è·å–é¢˜ç›®ç±»å‹
  getQuestionType(question) {
    // ä¼˜å…ˆä½¿ç”¨é¢˜ç›®æ•°æ®ä¸­çš„typeå­—æ®µ
    if (question.type) {
      return question.type;
    }
    
    // ç›´æ¥ä½¿ç”¨é¢˜ç›®çš„categoryå­—æ®µï¼Œè¿™æ˜¯æœ€å‡†ç¡®çš„æ–¹å¼
    const category = question.category || question.grammarPoint || '';
    
    // å¦‚æœcategoryå­˜åœ¨ä¸”ä¸ä¸ºç©ºï¼Œç›´æ¥è¿”å›åŸå§‹åˆ†ç±»åç§°
    if (category && category.trim() !== '') {
      return category;
    }
    
    // å¦‚æœæ²¡æœ‰categoryï¼Œè¿”å›é»˜è®¤å€¼
    return 'ç»¼åˆç»ƒä¹ ';
  },

  // ç¡®è®¤æ˜¯å¦è¿›å…¥ä¸“é¡¹ç»ƒä¹ 
  confirmSpecialPractice(grammarType) {
    // ç›´æ¥ä½¿ç”¨åŸå§‹åˆ†ç±»åç§°ï¼Œä¸å†è¿›è¡Œæ˜ å°„
    const typeName = grammarType || 'ç»¼åˆç»ƒä¹ ';
    
    wx.showModal({
      title: 'ä¸“é¡¹ç»ƒä¹ æé†’',
      content: `åŒç±»è¯­æ³•ç‚¹ï¼ˆ${typeName}ï¼‰é”™è¯¯ä¸‰æ¬¡ï¼Œæ˜¯å¦è¿›å…¥ä¸“é¡¹ç»ƒä¹ è¡¥æ¼ï¼Ÿ`,
      confirmText: 'è¿›å…¥ç»ƒä¹ ',
      cancelText: 'ç¨åå†è¯´',
      success: (res) => {
        if (res.confirm) {
          this.goSpecialPractice(grammarType);
        }
      }
    });
  },

  // è·³è½¬åˆ°ä¸“é¡¹ç»ƒä¹ 
  goSpecialPractice(grammarType) {
    // è·³è½¬åˆ°ä¸“é¡¹ç»ƒä¹ é¡µé¢
    const url = `/pages/special-practice/index?type=${grammarType}`;
    wx.navigateTo({
      url: url,
      success: () => {
        console.log(`è·³è½¬åˆ°${grammarType}ä¸“é¡¹ç»ƒä¹ æˆåŠŸ`);
      },
      fail: (error) => {
        console.error(`è·³è½¬åˆ°${grammarType}ä¸“é¡¹ç»ƒä¹ å¤±è´¥:`, error);
        wx.showToast({
          title: 'è·³è½¬å¤±è´¥',
          icon: 'none'
        });
      }
    });
  },

  // æ˜¾ç¤ºåç¼€çŸ¥è¯†å¡ç‰‡
  showSuffixCard() {
    this.setData({
      showSuffixCard: true
    });
  },

  // æ˜¾ç¤ºä¹¦å†™è§„åˆ™å¡ç‰‡
  showRuleCard() {
    this.setData({
      showRuleCard: true
    });
  },

  // å…³é—­çŸ¥è¯†å¡ç‰‡
  closeCard(type) {
    if (type === 'suffix') {
      this.setData({ showSuffixCard: false });
    } else if (type === 'rule') {
      this.setData({ showRuleCard: false });
    }
  },

  // å…³é—­åç¼€çŸ¥è¯†å¡ç‰‡
  closeSuffixCard() {
    this.setData({ showSuffixCard: false });
  },

  // å…³é—­ä¹¦å†™è§„åˆ™çŸ¥è¯†å¡ç‰‡
  closeRuleCard() {
    this.setData({ showRuleCard: false });
  },

  // è·³è½¬åˆ°åç¼€é›†è®­è¡¨æ ¼
  goSuffixTable() {
    this.closeSuffixCard();
    const url = `/pages/exercise-page/index?tables=noun_001,noun_002,noun_003,noun_004&type=noun&mode=special`;
    wx.navigateTo({
      url: url,
      success: () => {
        console.log('è·³è½¬åˆ°åç¼€é›†è®­è¡¨æ ¼æˆåŠŸ');
      },
      fail: (error) => {
        console.error('è·³è½¬å¤±è´¥:', error);
        wx.showToast({
          title: 'è·³è½¬å¤±è´¥',
          icon: 'none'
        });
      }
    });
  },

  // è·³è½¬åˆ°ä¹¦å†™è§„èŒƒè®­ç»ƒ
  goRuleTable() {
    this.closeRuleCard();
    const url = `/pages/exercise-page/index?tables=tense_writing_001,voice_001&type=writing&mode=special`;
    wx.navigateTo({
      url: url,
      success: () => {
        console.log('è·³è½¬åˆ°ä¹¦å†™è§„èŒƒè®­ç»ƒæˆåŠŸ');
      },
      fail: (error) => {
        console.error('è·³è½¬å¤±è´¥:', error);
        wx.showToast({
          title: 'è·³è½¬å¤±è´¥',
          icon: 'none'
        });
      }
    });
  },

  // æ–°å¢ï¼šäº‘å‡½æ•°è°ƒç”¨æ–¹æ³•

  // ä¿å­˜ç»ƒä¹ è¿›åº¦åˆ°äº‘ç«¯
  async saveProgressToCloud(grammarType, progress, errorCount) {
    try {
      // è·å–ç”¨æˆ·IDï¼ˆå¦‚æœæœ‰ç™»å½•æ€ï¼‰
      const userInfo = wx.getStorageSync('userInfo') || {};
      const userId = userInfo.openid || 'anonymous';
      
      const result = await wx.cloud.callFunction({
        name: 'practiceProgress',
        data: {
          action: 'save',
          userId: userId,
          grammarType: grammarType,
          progress: progress,
          errorCount: errorCount
        }
      });
      
      if (result.result.code === 200) {
        console.log('è¿›åº¦ä¿å­˜æˆåŠŸ:', grammarType, progress);
        return true;
      } else {
        console.error('è¿›åº¦ä¿å­˜å¤±è´¥:', result.result.message);
        return false;
      }
    } catch (error) {
      console.error('è°ƒç”¨äº‘å‡½æ•°å¤±è´¥:', error);
      return false;
    }
  },

  // è·å–ç»ƒä¹ è¿›åº¦
  async getProgressFromCloud(grammarType) {
    try {
      const userInfo = wx.getStorageSync('userInfo') || {};
      const userId = userInfo.openid || 'anonymous';
      
      const result = await wx.cloud.callFunction({
        name: 'practiceProgress',
        data: {
          action: 'get',
          userId: userId,
          grammarType: grammarType
        }
      });
      
      if (result.result.code === 200) {
        console.log('è·å–è¿›åº¦æˆåŠŸ:', result.result.data);
        return result.result.data;
      } else {
        console.error('è·å–è¿›åº¦å¤±è´¥:', result.result.message);
        return { progress: 0, errorCount: 0 };
      }
    } catch (error) {
      console.error('è°ƒç”¨äº‘å‡½æ•°å¤±è´¥:', error);
      return { progress: 0, errorCount: 0 };
    }
  },

  // è·å–ä¸“é¡¹ç»ƒä¹ è¡¨æ ¼åˆ—è¡¨
  async getPracticeTablesFromCloud() {
    try {
      const result = await wx.cloud.callFunction({
        name: 'practiceProgress',
        data: {
          action: 'getPracticeTables'
        }
      });
      
      if (result.result.code === 200) {
        console.log('è·å–ç»ƒä¹ è¡¨æ ¼æˆåŠŸ:', result.result.data);
        return result.result.data;
      } else {
        console.error('è·å–ç»ƒä¹ è¡¨æ ¼å¤±è´¥:', result.result.message);
        return [];
      }
    } catch (error) {
      console.error('è°ƒç”¨äº‘å‡½æ•°å¤±è´¥:', error);
      return [];
    }
  },

  // åœ¨é”™é¢˜å¤„ç†ä¸­ä¿å­˜è¿›åº¦
  async handleWrongQuestionWithProgress(question, index) {
    // å…ˆæ‰§è¡ŒåŸæœ‰çš„é”™é¢˜å¤„ç†é€»è¾‘
    this.handleWrongQuestion(question, index);
    
    // è·å–é¢˜ç›®ç±»å‹
    const grammarType = this.getQuestionType(question);
    
    if (grammarType) {
      // è·å–å½“å‰é”™è¯¯æ¬¡æ•°
      const currentCount = this.data.errorCounts[grammarType] || 0;
      
      // ä¿å­˜è¿›åº¦åˆ°äº‘ç«¯
      await this.saveProgressToCloud(grammarType, 0, currentCount);
    }
  },

  // æ–°å¢ï¼šå¤„ç†å®æ—¶æ‰¹æ”¹çš„é”™é¢˜ç»Ÿè®¡ï¼ˆé‡è½½æ–¹æ³•ï¼‰
  async handleWrongQuestionWithProgress(wrongQuestion, index) {
    // è·å–é¢˜ç›®ç±»å‹
    const grammarType = this.getQuestionType(wrongQuestion);
    
    if (grammarType) {
      // ç´¯åŠ é”™è¯¯æ¬¡æ•°
      const currentCount = this.data.errorCounts[grammarType] || 0;
      const newCount = currentCount + 1;
      
      const newErrorCounts = { ...this.data.errorCounts };
      newErrorCounts[grammarType] = newCount;
      
      this.setData({
        errorCounts: newErrorCounts,
        currentQuestionIndex: index,
        currentQuestionType: grammarType
      });
      
      console.log(`[å¤±å»ç„¦ç‚¹æ‰¹æ”¹é”™é¢˜ç»Ÿè®¡] ${grammarType} é”™è¯¯æ¬¡æ•°: ${newCount}`);
      
      // æ£€æŸ¥æ˜¯å¦è§¦å‘ä¸“é¡¹ç»ƒä¹ ï¼ˆé”™è¯¯3æ¬¡æˆ–ä»¥ä¸Šï¼‰
      if (newCount >= 3) {
        this.confirmSpecialPractice(grammarType);
      }
      
      // ä¿å­˜è¿›åº¦åˆ°äº‘ç«¯
      await this.saveProgressToCloud(grammarType, 0, newCount);
    }
  }
}); 